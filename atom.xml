<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤山的博客</title>
  
  
  <link href="https://gushan233.xyz/atom.xml" rel="self"/>
  
  <link href="https://gushan233.xyz/"/>
  <updated>2022-08-14T14:05:51.537Z</updated>
  <id>https://gushan233.xyz/</id>
  
  <author>
    <name>孤山</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nodejs express中间件和路由的使用 未写完</title>
    <link href="https://gushan233.xyz/nodejs-express%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://gushan233.xyz/nodejs-express%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-08-13T13:53:50.000Z</published>
    <updated>2022-08-14T14:05:51.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p>说起路由，你第一个想到的可能是路由器，两者之间确实有些相似之处，都是跟“地址”、“路径”相关联的。</p><p>nodeJs里面的路由，也是一个函数，当前端传送来某些数据时，根据这些数据路径的不同，执行不同的操作，再返回给前端。</p><p>下面是一个数字+1的例子</p><p>前端index.html</p><p>后端express</p><h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>这里只说nodejs里面的中间件，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是路由&quot;&gt;&lt;a href=&quot;#什么是路由&quot; class=&quot;headerlink&quot; title=&quot;什么是路由&quot;&gt;&lt;/a&gt;什么是路由&lt;/h2&gt;&lt;p&gt;说起路由，你第一个想到的可能是路由器，两者之间确实有些相似之处，都是跟“地址”、“路径”相关联的。&lt;/p&gt;
&lt;p&gt;n</summary>
      
    
    
    
    <category term="-node.js-" scheme="https://gushan233.xyz/categories/node-js/"/>
    
    
    <category term="-node.js- -后端-" scheme="https://gushan233.xyz/tags/node-js-%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>unity常用英语 v0.1</title>
    <link href="https://gushan233.xyz/unity%E7%94%A8%E8%8B%B1%E8%AF%AD/"/>
    <id>https://gushan233.xyz/unity%E7%94%A8%E8%8B%B1%E8%AF%AD/</id>
    <published>2022-08-04T09:30:00.000Z</published>
    <updated>2022-08-15T02:24:43.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unity常用英语-0-1"><a href="#unity常用英语-0-1" class="headerlink" title="unity常用英语 0.1"></a>unity常用英语 0.1</h1><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><table><thead><tr><th>Indie Games</th><th>独立游戏</th></tr></thead><tbody><tr><td>Indie game maker</td><td>独立游戏开发者</td></tr><tr><td>Game development</td><td>游戏开发</td></tr><tr><td>unity</td><td>团结，团结一致</td></tr><tr><td>Engine</td><td>引擎</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><table><thead><tr><th>Scene</th><th>场景</th></tr></thead><tbody><tr><td>File</td><td>文件</td></tr><tr><td>Edit</td><td>编辑</td></tr><tr><td>Assets</td><td>资源、资产</td></tr><tr><td>Component</td><td>组成部分、组件</td></tr><tr><td>Jobs</td><td></td></tr><tr><td>Hierachy</td><td>层次、图层</td></tr><tr><td>Inspector</td><td>检查、</td></tr><tr><td>Default</td><td>默认</td></tr><tr><td>Display</td><td>展示、显示</td></tr><tr><td>Package</td><td>包</td></tr><tr><td>Favorites</td><td>收藏</td></tr><tr><td>Fx</td><td>效果、特效</td></tr><tr><td>Build</td><td>构建、编译</td></tr><tr><td>Run</td><td>运行</td></tr><tr><td>debug</td><td>调试</td></tr><tr><td>undo</td><td>撤销</td></tr><tr><td>redo</td><td>重做</td></tr><tr><td>select</td><td>选择</td></tr><tr><td>deselect</td><td>取消选择</td></tr><tr><td>Children</td><td>孩子、子元素</td></tr><tr><td>Cut</td><td>剪切</td></tr><tr><td>paste</td><td>粘贴</td></tr><tr><td>copy</td><td>复制</td></tr><tr><td>Duplicate</td><td>重复</td></tr><tr><td>Rename</td><td>重命名</td></tr><tr><td>frame</td><td>框架</td></tr><tr><td>search</td><td>选择</td></tr><tr><td>pause</td><td>暂停</td></tr><tr><td>preferences</td><td>偏好、设置</td></tr><tr><td>shortcuts</td><td>捷径、快捷键</td></tr><tr><td>Explorer</td><td>探测器、资源管理器</td></tr><tr><td>path</td><td>路径</td></tr><tr><td>impot</td><td>导入</td></tr><tr><td>export</td><td>导出</td></tr><tr><td>Refresh</td><td>刷新</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><table><thead><tr><th>Empty</th><th>空</th></tr></thead><tbody><tr><td>transfrom</td><td>变换</td></tr><tr><td>Position</td><td>位置、定位</td></tr><tr><td>Sprites</td><td>精灵</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unity常用英语-0-1&quot;&gt;&lt;a href=&quot;#unity常用英语-0-1&quot; class=&quot;headerlink&quot; title=&quot;unity常用英语 0.1&quot;&gt;&lt;/a&gt;unity常用英语 0.1&lt;/h1&gt;&lt;h2 id=&quot;index&quot;&gt;&lt;a href=&quot;#inde</summary>
      
    
    
    
    <category term="-游戏开发-" scheme="https://gushan233.xyz/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="-unity-, -游戏开发-, -外语-" scheme="https://gushan233.xyz/tags/unity-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-%E5%A4%96%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>孤山网重置计划</title>
    <link href="https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%BD%91%E9%87%8D%E7%BD%AE%E8%AE%A1%E5%88%92/"/>
    <id>https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%BD%91%E9%87%8D%E7%BD%AE%E8%AE%A1%E5%88%92/</id>
    <published>2022-08-03T00:20:17.069Z</published>
    <updated>2022-08-03T00:21:55.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="孤山网2022冬-项目"><a href="#孤山网2022冬-项目" class="headerlink" title="孤山网2022冬 项目"></a>孤山网2022冬 项目</h1><h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><p>参与：寂静孤山</p><p>审阅：还是我</p><p>文档版本：v0.2</p><p>真的会有别人参与吗？</p><h2 id="开发环境和使用技术"><a href="#开发环境和使用技术" class="headerlink" title="开发环境和使用技术"></a>开发环境和使用技术</h2><p>Windows 10 + CentOs 8</p><p>代码编辑器：Vscode</p><p>浏览器：内核 Chromium 86版本</p><p>Mysql：版本8</p><p>Node.js：14及以上，如果时间精力允许会再开发一个jsp版本</p><p>Nodejs包：Express.js、moment.js、Socket.io</p><p>Vue：版本3</p><p>Git+私人服务器代码托管</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这个网站将作为未来孤山的信息发布平台，具有一般博客都具有的那些东西。</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><table><thead><tr><th>功能名词</th><th>功能描述</th></tr></thead><tbody><tr><td>账号登录注册注销</td><td>能使用电子邮箱登录和注册，</td></tr><tr><td>账号信息和身份</td><td>修改头像、昵称、电子邮箱、密码</td></tr><tr><td>文章</td><td>任何人都能在孤山网发布文章，可以发在不同的分区，文章使用md格式。用户可以查看自己权限组内能查看的文章，可以修改和删除文章。</td></tr><tr><td>搜索功能</td><td>可以搜索文章和帖子，并能按常见排序方式排序。</td></tr><tr><td>帖子</td><td>发帖删帖回复帖子点赞功能。</td></tr><tr><td>文章的留言功能</td><td>已登录用户可以留言。</td></tr><tr><td>公开的留言板</td><td>游客用户可以留言</td></tr><tr><td>博友功能</td><td>包括添加取消关注和黑名单、私信功能。</td></tr><tr><td>公告功能</td><td>每次发布的公告能给未看见的用户弹窗</td></tr><tr><td>其他功能</td><td>敏感词监控、赞助、live2d、画廊、开启总时间记录、访客数量信息记录等等。</td></tr></tbody></table><h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><p>V0.1：网页静态样式设计，基础布局，接口、数据库表确立。（2022年9月26日前，实际从现在空闲时间就要思考制作）</p><p>V0.2：实现留言板功能（2022年10月4日前）</p><p>V0.3：实现登录注册删除账户功能，发布修改删除文章功能。（2022年10月20日前）</p><p>V0.4：实现修改账户信息，访客数记录功能。（2022年10月30日前）</p><p>V0.5：实现点赞和搜索功能（2022年11月20日前）</p><p>V0.6：实现搜索功能（2022年11月28日前）</p><p>V0.7：实现帖子留言和点赞功能（2022年12月8日前）</p><p>V0.8：实现帖子功能（2022年12月15日前）</p><p>V0.9：实现公告功能（2022年12月24日前）</p><p>V1.0：实现基本博客功能（2023年1月结束前）</p><h2 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>账号：用户点击首页的“登录按钮“可以进行登录注册，使用电子邮箱来注册。登录后可以在同样的位置点击头像来修改个人信息，包括昵称、头像、性别、年龄、个人简介、地址、绑定的电子邮箱、密码等，用户还有等级、硬币数等信息。</p><p>文章：用户可以发文章、改文章、删文章，文章使用md格式，每个文章都可以点赞或投币和分享。</p><p>搜索：用户可以搜索文章和别的用户，可以加以筛选条件。</p><p>。。。</p><h3 id="视觉设计"><a href="#视觉设计" class="headerlink" title="视觉设计"></a>视觉设计</h3><p>扁平化+二次元</p><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;孤山网2022冬-项目&quot;&gt;&lt;a href=&quot;#孤山网2022冬-项目&quot; class=&quot;headerlink&quot; title=&quot;孤山网2022冬 项目&quot;&gt;&lt;/a&gt;孤山网2022冬 项目&lt;/h1&gt;&lt;h2 id=&quot;参与者&quot;&gt;&lt;a href=&quot;#参与者&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>孤山的电波</title>
    <link href="https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%9A%84%E7%94%B5%E6%B3%A2/"/>
    <id>https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%9A%84%E7%94%B5%E6%B3%A2/</id>
    <published>2022-08-02T10:07:16.121Z</published>
    <updated>2022-08-02T10:13:03.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="amp-36-amp"><a href="#amp-36-amp" class="headerlink" title="&amp;*36$^(@)^&amp;"></a>&amp;*36$^(@)^&amp;</h2><p>特露露点一零，理性是感性，理性不是感性，它们是相反的，他是三天前死，逻辑，冷漠的人们，故事在1999，存在是连续的吗，记忆是连续的吗，我们为何存在于此，有上帝吗，有空间吗？有时间吗？有天空吗？有世界吗？有意大利面吗？有爱情吗？</p><p>Trollu point one zero, reason is sensual, reason is not sensual, they are opposite, he died three days ago, logic, indifferent people, story in 1999, is existence continuous, is memory continuous, why do we exist here, is there a God, is there space? Is there time? Is there a sky? Is there a world? Is there spaghetti? Is there love? </p><p>愚者说自由，但世界上没有自由，愚者说平等，但世界上没有平等，愚者说公正，但世界上没有公正。</p><p>A fool says freedom, but there is no freedom in the world; a fool says equality, but there is no equality in the world; a fool says justice, but there is no justice in the world.</p><p>日常，颠倒的日常是日常，相反的日常是日常，没有日常，到处都是日常，一天天的过去，人类不会六天灭亡。是我，但又不是我，像我，但又不像我，是又不是。紧张的情感在大众之中传递.</p><p>Everyday, upside down everyday is everyday, opposite everyday is everyday, there is no everyday, everywhere is everyday, day by day, humanity will not perish in six days. It is me, but not me, like me, but not like me, yes and no. Tense emotions pass among the masses .</p><p>入侵学校、入侵公司、入侵宗教、入侵民族、入侵国家，世界上的故事，世界本身的故事，世界没有故事，虚无主义的谬论，观察者之差。</p><p>Invasion of schools, invasion of companies, invasion of religions, invasion of peoples, invasion of nations, stories in the world, stories of the world itself, stories of the world without stories, the fallacy of nihilism, the difference of the observer.</p><p>狂起来了。他狂起来了，他死了。连同他的灵魂，被巨大的生活给吞没了。</p><p>Mad up. He went wild and he died. Along with his soul, he was swallowed up by the great life.</p><p>哲理，啫喱，这里，着哩，哲理，折哩，这厉，语言游戏，预言游戏，雨燕游戏，浴盐游戏，鱼眼游戏，语嫣游戏，油盐游戏，有限的游戏，无限的游戏，重中之重在重中之重。羽毛在羽毛里面，泰山在泰山里面，问题包含了对自身的回答，事物包括了对自身的否定，椅子没有完美的原型，白马黑马坐在一筐。</p><p>games, fish eye games, Yuyan games, oil and salt games, limited games, infinite games, the heaviest of the heaviest in the heaviest. Feathers inside feathers, Tarzan inside Tarzan, questions contain answers to themselves, things include the negation of themselves, the chair has no perfect prototype, the white horse and the black horse sit in a basket.</p><p>圆远处也可以是方，方远处也可以是园，人，人，到处都是人，人和蚂蚁一样多，人产生了意识，人描述自己，一代又一代。</p><p>A circle far away can also be a square, a square far away can also be a garden, people, people, people everywhere, people as many as ants, people generate consciousness, people describe themselves, generation after generation.</p><p>空无将会来临，有离开世界，但世界外还是世界，有平视一切，最后还是离开世界，有意义加深，遗憾离开的，幸福离开的，有珍惜当下的，临界向他展开。</p><p>A circle far away can also be a square, a square far away can also be a garden, people, people, people everywhere, people as many as ants, people generate consciousness, people describe themselves, generation after generation.</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>孤山并不是疯了傻了，也不是信了什么宗教，我算是无神论者。只是随便想想写点奇奇怪怪的东西，毕竟最近更不出来东西，本文虽然看似不明所以，但还是有点哲理，虽然是个屁的道理，但就先更到这里，以后还更在孤山网里。</p><p>skr~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;amp-36-amp&quot;&gt;&lt;a href=&quot;#amp-36-amp&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;*36$^(@)^&amp;amp;&quot;&gt;&lt;/a&gt;&amp;amp;*36$^(@)^&amp;amp;&lt;/h2&gt;&lt;p&gt;特露露点一零，理性是感性，理性不是感性，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>咕咕的常见算法实现</title>
    <link href="https://gushan233.xyz/%E4%B8%BB%E6%B5%81%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gushan233.xyz/%E4%B8%BB%E6%B5%81%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-08-02T10:06:41.289Z</published>
    <updated>2022-08-03T00:22:42.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与数据结构的地图-孤山-0-1"><a href="#算法与数据结构的地图-孤山-0-1" class="headerlink" title="算法与数据结构的地图 孤山 0.1"></a>算法与数据结构的地图 孤山 0.1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于任何一个领域的知识来说，都需要一张地图，有顺序的从前到后带你慢慢提升，许多经典书籍的目录是一张地图，网上的学习路线也是一张地图。</p><p>而我呢。。。只是很早就了解过然后现在在整理知识的小学渣罢了。所以，以下的东西，仅供参考。</p><p>有java、C&#x2F;C++、python、JS语言描述， 不过除非某种语言实现某些操作有特殊性，不然在解释程序时只用java语言。</p><h1 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span>&#123;<br>        <span class="hljs-type">int</span> i,j,temp,t;<br>        <span class="hljs-keyword">if</span>(low&gt;high)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        i=low;<br>        j=high;<br>        <span class="hljs-comment">//temp就是基准位</span><br>        temp = arr[low];<br> <br>        <span class="hljs-keyword">while</span> (i&lt;j) &#123;<br>            <span class="hljs-comment">//先看右边，依次往左递减</span><br>            <span class="hljs-keyword">while</span> (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//再看左边，依次往右递增</span><br>            <span class="hljs-keyword">while</span> (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-comment">//如果满足条件则交换</span><br>            <span class="hljs-keyword">if</span> (i&lt;j) &#123;<br>                t = arr[j];<br>                arr[j] = arr[i];<br>                arr[i] = t;<br>            &#125;<br> <br>        &#125;<br>        <span class="hljs-comment">//最后将基准为与i和j相等位置的数字交换</span><br>         arr[low] = arr[i];<br>         arr[i] = temp;<br>        <span class="hljs-comment">//递归调用左半数组</span><br>        quickSort(arr, low, j-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//递归调用右半数组</span><br>        quickSort(arr, j+<span class="hljs-number">1</span>, high);<br>    &#125;<br> <br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">62</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">19</span>&#125;;<br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="最拉的——普通查找"><a href="#最拉的——普通查找" class="headerlink" title="最拉的——普通查找"></a>最拉的——普通查找</h4><h4 id="不错的——二分查找"><a href="#不错的——二分查找" class="headerlink" title="不错的——二分查找"></a>不错的——二分查找</h4><h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><h3 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h3><p>所谓数据结构，就是数据如何组织的研究，在不同情况不同要求下，有些结构就是比其他结构快，是时间换空间，还是空间换时间之类的考虑，</p><p>数据结构主要有八种，下面会讲大概的原理和使用</p><ul><li>数组</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>散列表&#x2F;哈希表</li><li>堆</li><li>图</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组相信你在学习java的早期就学过，数组是连续的，意味着在内存中也是连续的，这样有个缺点，就是创建的时候，尤其是数组容量还很大的时候，要专门在内存中腾出一大块空地去安置。而且要在中间插入或者删除一个元素的时候，那个元素的后面要整块移动，很是麻烦。</p><p>但是也有有其优点，就是在查询和遍历的时候很快，毕竟元素都在内存中挨在一起嘛。</p><h4 id="实现、增删改查、遍历数组"><a href="#实现、增删改查、遍历数组" class="headerlink" title="实现、增删改查、遍历数组"></a>实现、增删改查、遍历数组</h4><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shuzu1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6</span>]; <span class="hljs-comment">//创建一个能装六个元素固定大小的数组</span><br>        <span class="hljs-type">int</span>[] data2=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//创建数组并赋值</span><br>        ArrayList listData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">//创建一个容量可以变化的数组</span><br>        ArrayList&lt;Integer&gt; listData2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(); <span class="hljs-comment">//同上，不过限定类型为int</span><br><br>        <br>        data2[<span class="hljs-number">0</span>]=<span class="hljs-number">33</span>;<span class="hljs-comment">//一般数组增或改</span><br>        data=<span class="hljs-literal">null</span>;<span class="hljs-comment">//消灭一个数组</span><br><br>        listData.add(<span class="hljs-number">33</span>);<span class="hljs-comment">//ArrayList增</span><br>        listData.add(<span class="hljs-number">12</span>);<br>        listData.add(<span class="hljs-number">11</span>);<br>        listData.add(<span class="hljs-number">53</span>);<span class="hljs-comment">//同时添加多个元素</span><br>        listData.set(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//ArrayList改</span><br>        listData.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//ArrayList删</span><br><br>        <span class="hljs-comment">//————————————遍历————————————————</span><br>        <span class="hljs-comment">//一般数组一般遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data2.length;i++)&#123;<br>            System.out.print(data2[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-comment">//一般数组增强for循环遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:data2)&#123;<br>            System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br><br>        System.out.println();<br>        <span class="hljs-comment">//arraylist一般遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; listData.size(); i++) &#123;<br>            System.out.print(listData.get(i)+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-comment">//arraylist增强for遍历,如果加了泛型 i的类型也要对应的改变</span><br>        <span class="hljs-keyword">for</span> (Object i:listData) &#123;<br>            System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-comment">//arraylist使用迭代器</span><br>        <span class="hljs-keyword">for</span>(Iterator&lt;String&gt; it=listData.iterator();it.hasNext();)<br>        &#123;<br>            System.out.println(it.next());<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-comment">//————————————复制————————————————</span><br>        <span class="hljs-comment">//一般数组复制</span><br>        <span class="hljs-type">int</span>[] data3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[data2.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data2.length;i++)&#123;<br>            data3[i]=data2[i];<br>        &#125;<br>        <span class="hljs-comment">//arraylist复制</span><br>        ArrayList listdata3=(ArrayList) listData.clone();<br>        System.out.println(listdata3.get(<span class="hljs-number">1</span>));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>c&#x2F;c++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> balance[<span class="hljs-number">10</span>];<span class="hljs-comment">//创建一个容量为10的整型数组</span><br><span class="hljs-type">float</span> num[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">4.0</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">6.0</span>&#125;;<br></code></pre></td></tr></table></figure><p>python</p><p>C#</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表和数组像一对相爱相杀的好兄弟，因为他俩的优缺点相反。</p><p>数组是挨在一起的，而链表的元素在内存中是分开的，那么怎么找到这些元素呢？每一个元素的末尾都记录了下一个元素的地址，这样插入就很简单了，先随便在内存中找个位置，然后在上一个元素末尾插入地址。但是要查找起来就麻烦了，你不能像数组一样直接从某个数值开始做加法获得数值，要不断的下一个、下一个、下一个。。。这就导致了查找和遍历缓慢。</p><p>链表分为单向链表和双向链表</p><p>限制：无</p><h4 id="实现、增删改查、遍历链表"><a href="#实现、增删改查、遍历链表" class="headerlink" title="实现、增删改查、遍历链表"></a>实现、增删改查、遍历链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java LinkedList类实现链表</span><br>LinkedList&lt;Integer&gt; linkList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>linkList.add(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//其余使用方法与arraylist接近</span><br></code></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列就如起名，先进去的元素先出来。放入元素称为入队，取出元素称为出队。</p><p>限制：单向输出</p><h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br>......<br><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br><span class="hljs-comment">//队列增</span><br>queue.offer(<span class="hljs-string">&quot;a&quot;</span>);<br>queue.offer(<span class="hljs-string">&quot;b&quot;</span>);<br>queue.offer(<span class="hljs-string">&quot;c&quot;</span>);<br>queue.offer(<span class="hljs-string">&quot;d&quot;</span>);<br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span>(String q : queue)&#123;<br>     System.out.println(q);<br>&#125; <br><br>queue.poll();<span class="hljs-comment">//返回第一个元素，并删除</span><br>queue.element();<span class="hljs-comment">//返回第第一个元素，为空时抛出异常</span><br>queue.peek();<span class="hljs-comment">//返回第一个元素，为空时返回null</span><br><br>System.out.println(<span class="hljs-string">&quot;————————————————&quot;</span>);<br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span>(String q : queue)&#123;<br>      System.out.println(q);<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈的特点是，先进后出，或者说是后进先出。就像一堆稻草，先放进去的一般先拿出来，顺便说一下，超市的货柜往往是队列，因为快过期的产品往往放在前面，先进先出，才更容易卖掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br><span class="hljs-comment">//进栈</span><br>stack.push(<span class="hljs-number">23</span>);<br>stack.push(<span class="hljs-number">29</span>);<br>stack.push(<span class="hljs-number">36</span>);<br><span class="hljs-comment">//出栈</span><br>stack.pop();<br><span class="hljs-comment">//取栈顶值（不出栈）</span><br>stack.peek();<br><span class="hljs-comment">//判断栈是否为空</span><br>System.out.println(stack.isEmpty());<br></code></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h3 id="散列表-》hash表"><a href="#散列表-》hash表" class="headerlink" title="散列表-》hash表"></a>散列表-》hash表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hashDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//创建</span><br>    <span class="hljs-comment">//对于java中自带的hash表,如果报错，要么在main方法前加上@SuppressWarnings(&quot;unchecked&quot;)，要么加泛型</span><br>    Hashtable&lt;String,Integer&gt; ht = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;String,Integer&gt;();<br>    Enumeration names;<br>    <br>    <span class="hljs-comment">//添加</span><br>    ht.put(<span class="hljs-string">&quot;sans&quot;</span>,<span class="hljs-number">23</span>);<br>    ht.put(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">19</span>);<br>    ht.put(<span class="hljs-string">&quot;wang&quot;</span>,<span class="hljs-number">20</span>);<br>    ht.put(<span class="hljs-string">&quot;alice&quot;</span>,<span class="hljs-number">18</span>);<br><br>    <span class="hljs-comment">//删除</span><br>    ht.remove(<span class="hljs-string">&quot;sans&quot;</span>);<br><br>    <span class="hljs-comment">//改查</span><br>    System.out.println(ht.get(<span class="hljs-string">&quot;alice&quot;</span>));<br>    ht.replace(<span class="hljs-string">&quot;alice&quot;</span>,<span class="hljs-number">17</span>);<br><br><br>    names = ht.keys();<br>    String str;<br>    <span class="hljs-comment">//遍历表</span><br>    <span class="hljs-keyword">while</span>(names.hasMoreElements()) &#123;<br>        str = (String) names.nextElement();<br>        System.out.println(str + <span class="hljs-string">&quot;: &quot;</span> +<br>        ht.get(str));<br>     &#125;<br><br>     System.out.println(<span class="hljs-string">&quot;表是否为空：&quot;</span>+ht.isEmpty());<br>     ht.clear();<br>     System.out.println(<span class="hljs-string">&quot;表是否为空：&quot;</span>+ht.isEmpty());<br><br>     System.out.println(<span class="hljs-string">&quot;Done&quot;</span>);<br>    <br>  &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h1 id="具体数据结构与算法研究"><a href="#具体数据结构与算法研究" class="headerlink" title="具体数据结构与算法研究"></a>具体数据结构与算法研究</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="1、梦的开始——两数之和"><a href="#1、梦的开始——两数之和" class="headerlink" title="1、梦的开始——两数之和"></a>1、梦的开始——两数之和</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,3], target = 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h4 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h4><p>最容易想到的算法</p><p>C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; numsSize; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                <span class="hljs-type">int</span>* ret = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">2</span>);<br>                ret[<span class="hljs-number">0</span>] = i, ret[<span class="hljs-number">1</span>] = j;<br>                *returnSize = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">return</span> ret;<br>            &#125;<br>        &#125;<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br>        <br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>             <span class="hljs-type">int</span>[] indexs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=i+<span class="hljs-number">1</span>;z&lt;nums.length;z++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[z]==target)&#123;<br>                    <span class="hljs-type">int</span>[] a=&#123;i,z&#125;;<br>                    indexs[<span class="hljs-number">0</span>]=i;<br>                    indexs[<span class="hljs-number">1</span>]=z;<br>                    <span class="hljs-keyword">return</span> indexs;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三行一个for循环，第四行定义一个数组用来存储遍历的值，然后再写一个循环，注意题目要求，数组中同一个元素在答案里不能重复出现，所以定义z变量时要i+1避免重复，为了防止溢出，前面的for判断条件也是数组大小-1，随后一个if判断如果数组中的两个数字等于所给的target目标值就返回indexs数组，如果几轮循环尽了都没找到，就返回一个空数组。时间复杂度为O(2n)，时间复杂度为O（1）</p><h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><p>以空间换时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; hashtable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;<br>            &#125;<br>            hashtable.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三行定义了一个hash表，</p><h3 id="2、寻找数组中的最大值和最小值"><a href="#2、寻找数组中的最大值和最小值" class="headerlink" title="2、寻找数组中的最大值和最小值"></a>2、寻找数组中的最大值和最小值</h3><h4 id="直接找"><a href="#直接找" class="headerlink" title="直接找"></a>直接找</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与数据结构的地图-孤山-0-1&quot;&gt;&lt;a href=&quot;#算法与数据结构的地图-孤山-0-1&quot; class=&quot;headerlink&quot; title=&quot;算法与数据结构的地图 孤山 0.1&quot;&gt;&lt;/a&gt;算法与数据结构的地图 孤山 0.1&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>孤山用的软件</title>
    <link href="https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83/"/>
    <id>https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83/</id>
    <published>2022-08-02T10:06:41.288Z</published>
    <updated>2022-08-02T10:13:26.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="孤山用的软件"><a href="#孤山用的软件" class="headerlink" title="孤山用的软件"></a>孤山用的软件</h1><h2 id="这里收集孤山以前、现在、未来使用过的不错的软件"><a href="#这里收集孤山以前、现在、未来使用过的不错的软件" class="headerlink" title="这里收集孤山以前、现在、未来使用过的不错的软件"></a>这里收集孤山以前、现在、未来使用过的不错的软件</h2><p>本文章长期置顶</p><p>推荐软件包括Windows、安卓和IOS。</p><p>观察中：还没有用，但想试试看</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="常用浏览器"><a href="#常用浏览器" class="headerlink" title="常用浏览器"></a>常用浏览器</h3><p>浏览器我用的是百分浏览器，其实chrome原生、火狐、edge浏览器也不错。</p><h3 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h3><p>浏览器插件主推以下几款</p><p>​油猴：油猴是一个平台，可以装许多脚本实现许多实用的功能，包括但不限于：</p><p>​下载被限制的视频、音频、图片、文档</p><p>​去除广告、去除网页限制</p><p>​自动翻译、优化。。。</p><p>​wappalyzer：用来查看一个网站是由什么技术实现的，对于学习前后端是很有用的。</p><p>​HTML DOM：查看网页的DOM结构，在学习 dom编程的时候很有用。</p><p>​ip地址国家：查看一个网站的ip归属哪国。</p><h2 id="IDE和编程相关"><a href="#IDE和编程相关" class="headerlink" title="IDE和编程相关"></a>IDE和编程相关</h2><p>Vscode，没装插件之前，他是一款普通的编辑器，但是加上插件，就会变得超强，C、Java、前端、后端，各种语言无所不能。</p><p>sublinme：因为是付费软件和更换vscode后（重要原因：vscode可以换上我的miku背景），就不常用了。作为轻量编辑器也是不错的。</p><p>IDEA：用来写java，个人感觉比ecliptce好用。</p><p>git：程序员必备版本管理。</p><p>Ren‘py：视觉小说游戏引擎。</p><p>vb6：已经是回忆了。。。</p><p>还有JDK、nodejs、C&#x2F;C++、C#、Python等的环境。。。</p><h2 id="图片处理和绘画设计"><a href="#图片处理和绘画设计" class="headerlink" title="图片处理和绘画设计"></a>图片处理和绘画设计</h2><p>ps：不必多说，多数人都得装一个吧。因为中考学了ps8，中专计算机专业学了ps CS6，自己重装系统前是2020版本，现在用的是2021，基本操作都熟悉，就是通道、路径和印章工具，我到现在还不知道怎么用。</p><p>SAI2：小巧快速的绘画软件</p><p>procrate：ipad端知名绘画软件</p><p>Pose Arch：绘画人体参考</p><p>MagicPoser：绘画人体参考</p><p>XD：只要你有adobe或者类似软件的基础，你就能很快上手这款ui设计软件。</p><p>ID：我拿它用来给我要写的“书”或别的文档排过版。</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><h4 id="视频软件"><a href="#视频软件" class="headerlink" title="视频软件"></a>视频软件</h4><p>Pr：剪视频。但是我最近一年都没有制作自己的视频。。。</p><p>Adobe Animtion：Adobe出的动画软件，是flash的延续，我视频空间里面的op模仿就是用这个来做的。</p><p>OpenToonz：动画软件，观察中</p><p>达芬奇：同样是剪视频。</p><p>Ae：上手难精通也难的软件，目前没有用到它的需求，但还是留在电脑里，万一（不，是未来一定会有）有需求了呢？</p><p>Arctime：用来给视频加字幕，很好用，jk连打很上头。</p><p>小丸工具箱：拿来压制视频。</p><p>live2D：已经两年没碰了（笑）</p><p>OBS：直播推流和录屏，虽然我一次直播也没有过。</p><h4 id="视频插件"><a href="#视频插件" class="headerlink" title="视频插件"></a>视频插件</h4><p>因为好久没有碰过视频软件而且以前也不常用。用过什么插件都忘了。。。我只记得有红巨星和AE脚本管理器之类的</p><h2 id="音频相关"><a href="#音频相关" class="headerlink" title="音频相关"></a>音频相关</h2><h3 id="音频相关软件"><a href="#音频相关软件" class="headerlink" title="音频相关软件"></a>音频相关软件</h3><h4 id="宿主软件"><a href="#宿主软件" class="headerlink" title="宿主软件"></a>宿主软件</h4><p>Au：现在不常用了</p><p>Cubase：编曲和混音软件，个人感觉这个软件在所有编曲软件中是取中庸的。</p><p>Fl studio：编曲和混音软件，但更加适合去制作电音。</p><p>Reaper：编曲和混音软件，高度自定义，可编程，没玩明白。</p><p>库乐队：偶尔在平板上玩玩</p><h4 id="打谱"><a href="#打谱" class="headerlink" title="打谱"></a>打谱</h4><p>amuse：拿来写谱子</p><p>Sibelius：另一款写谱子的软件</p><h4 id="歌声合成"><a href="#歌声合成" class="headerlink" title="歌声合成"></a>歌声合成</h4><p>Utau：虚拟歌姬软件，做鬼畜常用。</p><p>VOCALOID：是承载洛天依、言和等虚拟歌姬的软件，用这个软件让她们唱出来的过程称为调教。</p><p>Synthesizer V：新兴歌声合成软件，五维介质的赤羽、诗岸、苍穹和海伊就是这个软件的声库。</p><p><em>CeVIO</em> Creative Studio：新兴歌声合成软件</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="编曲插件："><a href="#编曲插件：" class="headerlink" title="编曲插件："></a>编曲插件：</h3><h4 id="音源"><a href="#音源" class="headerlink" title="音源"></a>音源</h4><p>​xpand2，体积不大但有很多音色的综合性音源，适合新手入门</p><p>​piano v2：小巧的钢琴音源</p><p>​kontakt，这是一个承载其他音源的平台，有很多音源依赖于它，可以加载进宿主软件</p><p>​血清合成器</p><h4 id="效果器："><a href="#效果器：" class="headerlink" title="效果器："></a>效果器：</h4><p>​fabfilter系列：我直到现在也只用过里面的Pro-Q。</p><p>​iZotope Ozone Pro系列：臭氧效果器套件</p><p>​Waves系列</p><p>​melodyne：修音插件，也可以单独运行</p><p>​</p><h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><p>​Unity hub：Unity引擎的管理中心，Unity不仅在游戏领域发挥着作用，还正在全面渗透工业、影视、动画、新媒体艺术等诸多领域。</p><p>​Blender：在去年听说就连插画师应聘也要会一款3D软件了。都这么卷了吗？</p><h2 id="写作和办公"><a href="#写作和办公" class="headerlink" title="写作和办公"></a>写作和办公</h2><p>Office三件套：笔记本附带的学生与个人的正版。</p><p>OneNote：以前经常拿来记笔记，现在则转为Goodnotes了。</p><p>GoodNote：平板上常用的软件，目前常拿来记笔记</p><p>Xmind：拿来画思维导图。</p><p>Typora：很好的markdown写作软件，这个文章就是用它写的。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>Steam：游戏平台，g胖总是用打折来掏空你的钱包，还有，他不会数3！</p><p>Minecraft：</p><p>​沙盒游戏中永远的神！记得第一次玩大概是在初一刚有智能手机的那会（似乎还有更久远的记忆，在。。），玩基岩版的远古版本，0.3.0。那时候没有箱子，方块也只有二十几种，好像也没有饥饿值，但是我依然在里面玩的很开心，那时候也在看着那些优酷博主的视频，坑爹哥、奇怪君、籽岷。。。</p><p>​之后买了新的一体机，初中制作过整合包，记得塞入了npc、更多的门、糖果世界、暮色森林等杂七杂八的mod，当时用的是mod最多的1.7.10，这个整合包现在估计找不到了。</p><p>​也有尝试在游戏中还原自己的初中，但只做了不到5%，之后就是中专的时候，在机房用服务端整合包开服一起联机。也有尝试制作mod，但是那时学不会Java和javaScript。在专三买了minecraft的pc java端正版。</p><p>​就是这样玩了断断续续的六年</p><p>钢铁雄心4：<del>战犯模拟器</del>（bushi），不错的策略游戏，可以扮演二战前夕的国家意识，改变历史进程，不过在外人看来是一款地图填色游戏。</p><p>文明6：从下午五点开始玩，玩完一把，发现到了早上七点，这游戏是真的杀时间。</p><p>泰拉瑞亚：常被称为2D版的Minecraft，优秀的游戏，在100多M的体积里塞了如此多的元素，让玩家在其中不断探索，可玩性很高。</p><p>战地二：在我专二和初中的时候，好像经常玩。不知道为什么，战地的其他系列我提不起兴趣，但是愿意玩战地二。有一段时间我经常逛贴吧和BF2中文网，看看有什么好玩的模组，模组真的是把这个游戏的寿命大大延长了。</p><p>脑叶公司：此游戏观察中</p><p>极乐迪斯科：此游戏观察中</p><p>主播女孩重度依赖：此游戏观察中</p><p>铁锈战争：类似红警的RTS即时战略游戏，自由度很高，支持模组。</p><p>信任的进化：玩游戏学习一些博弈论的知识。</p><p>各种视觉小说：</p><p>​关于视觉小说（galgame属于其中）这个媒介，是不是游戏都还存在争议，私认为，如果存在玩家能改变的部分（在视觉小说中主要就是选项），就是游戏，不过这样排除了那些一条线到底的视觉小说。</p><p>​视觉小说衍生的作品出圈的有很多，比如CLANNAD、FATE、命运石之门，都是游戏反馈很好之后出的动画。</p><p>东方系列：</p><p>​现在流行的东方亚文化其实最开始是从ZUN教主做出来的一款游戏开始的。。。</p><p>​我玩过东方红魔城、星莲船，虽然都没有到过第三关之后。</p><h2 id="阅读和学习"><a href="#阅读和学习" class="headerlink" title="阅读和学习"></a>阅读和学习</h2><p>Kindle：我有物理上的kindle（指我的墨水屏阅读器），还有Kindle app，亚马逊在中国的电子书业务没有以前那么好了。</p><p>微信读书：你能经常漂到无限阅读卡，所以近乎等于免费看书。</p><p>图书：苹果自带的阅读软件</p><p>DeepL：翻译软件，准确度很高</p><p>网易有道词典</p><p>NetNewsWire：读SSR订阅内容</p><p>Leet：刷算法题，虽然写这篇文章的时候只通了第一关。</p><p>EarMaster：练视唱练耳</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>BandZip：以前用Winrar，现在用这个，因为更好看还有乱码转换的功能，6.26以上版本的版本变成付费制了。可以在设置里把自动更新关掉。</p><p>PotPlayer：好用的播放器</p><p>Rainmeter：是能在你的桌面上加上各种装饰和小工具插件的软件，初二的时候发现了它，当时可爱折腾了，把桌面搞得花里胡哨，现在只放些简单的插件。</p><p>wallpaper engine：动态壁纸，在steam，18块钱（不知道现在是不是这个价）买的其实是创意工坊，并且软件中的某个选项让许多少年为之魂牵梦绕。。。现在不常用了。</p><p>Vmware：虚拟机</p><p>微pe：我u盘里面的pe系统</p><p>XDisplay：把ipad变成电脑的第二块屏幕。</p><p>RD Client：IOS和安卓设备连接控制电脑</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;孤山用的软件&quot;&gt;&lt;a href=&quot;#孤山用的软件&quot; class=&quot;headerlink&quot; title=&quot;孤山用的软件&quot;&gt;&lt;/a&gt;孤山用的软件&lt;/h1&gt;&lt;h2 id=&quot;这里收集孤山以前、现在、未来使用过的不错的软件&quot;&gt;&lt;a href=&quot;#这里收集孤山以前、现在、未来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>孤山的js小笔记</title>
    <link href="https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%9A%84js%E7%AC%94%E8%AE%B0/"/>
    <id>https://gushan233.xyz/%E5%AD%A4%E5%B1%B1%E7%9A%84js%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-02T10:06:41.286Z</published>
    <updated>2022-08-02T10:13:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="孤山的js笔记"><a href="#孤山的js笔记" class="headerlink" title="孤山的js笔记"></a>孤山的js笔记</h1><p>如果说html是网页的身体，css是网页的衣服，那么，js就是网页的行为。有了js，网页就多了一些活力。</p><p>孤山使用环境：nodejs v16.14.2、浏览器内核Chromium 86.0.4240.198、vscode 1.66.2、Windows10 2004。</p><p>本笔记是站在对方已经有一定js编程基础，拿来复习用的。这是我知识整理的产物。</p><h2 id="一、基础部分"><a href="#一、基础部分" class="headerlink" title="一、基础部分"></a>一、基础部分</h2><h3 id="1、js的信息输出"><a href="#1、js的信息输出" class="headerlink" title="1、js的信息输出"></a>1、js的信息输出</h3><p>js的信息输出有四种方式：控制台、警告框、写入html文档、写入html，本笔记如果没有用到html，一律在vscode内用nodeJs运行。</p><p>控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;信息&quot;</span>);</span><br></pre></td></tr></table></figure><p>警告框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">alent</span>(<span class="string">&quot;信息&quot;</span>);</span><br></pre></td></tr></table></figure><p>写入html标签（id方式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;标签ID名&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;信息&quot;</span>;</span><br></pre></td></tr></table></figure><p>写入html文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;内容&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h3><p>js的类型分为基本类型和引用类型。</p><p>基本类型有：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p><p>引用类型有：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><p>因为js拥有动态类型，所以相同的一个变量可视作不同的类型.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;               <span class="comment">// x 为 undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;           <span class="comment">// 现在 x 为数字</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span>;      <span class="comment">// 现在 x 为字符串</span></span><br></pre></td></tr></table></figure><p>变量的数据类型可通过typeOf操作符来查看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;John&quot;</span>                <span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>                  <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>                 <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]             <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125; <span class="comment">// 返回 object</span></span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“你今天吃饭了吗”</span><br><span class="line">‘<span class="number">2333</span>’</span><br><span class="line">“宅在家里真不错\n”</span><br></pre></td></tr></table></figure><p>字符串内可以套引号，只要不是最外面的那层引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer=<span class="string">&quot;It&#x27;s alright&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer=<span class="string">&quot;He is called &#x27;Johnny&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer=<span class="string">&#x27;He is called &quot;Johnny&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>数字举例：2333、20、3&#x2F;2、4.1</p><p>js不同于java或其他强类型语言，数字不区分浮点数和整数，可以带小数点，也可以不带。</p><p>极大或极小的数字可以用科学计数法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x1=<span class="number">114514.00</span>;      <span class="comment">//使用小数点来写</span></span><br><span class="line"><span class="keyword">var</span> x2=<span class="number">114514</span>;         <span class="comment">//不使用小数点来写</span></span><br><span class="line"><span class="keyword">var</span> y=<span class="number">123e5</span>;      <span class="comment">// 12300000</span></span><br><span class="line"><span class="keyword">var</span> z=<span class="number">123e-5</span>;     <span class="comment">// 0.00123</span></span><br></pre></td></tr></table></figure><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>布尔（逻辑）只能有两个值：true 或 false。常常用于条件测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> a2=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>接下来是引用类型</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数值有两种创建方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Gushans</span>=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="title class_">Gushans</span>[<span class="number">0</span>]=<span class="string">&quot;YuanChu&quot;</span>;</span><br><span class="line"><span class="title class_">Gushans</span>[<span class="number">1</span>]=<span class="string">&quot;HanQing&quot;</span>;</span><br><span class="line"><span class="title class_">Gushans</span>[<span class="number">2</span>]=<span class="string">&quot;ShuLiu&quot;</span>;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="comment">//var Gushans=new Array(&quot;YuanChu&quot;,&quot;HanQing&quot;,&quot;ShuLiu&quot;);</span></span><br></pre></td></tr></table></figure><p>数组下标是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：，就像java的Hashcode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">firstname</span>:<span class="string">&quot;Gushan&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure><p>对象被直接输出时，会直接输出定义语句，但是用下面两种方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=person.<span class="property">lastname</span>;</span><br><span class="line">name=person[<span class="string">&quot;lastname&quot;</span>];</span><br></pre></td></tr></table></figure><p>就可以获取到对象属性。</p><h4 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h4><p>Undefined 这个值表示变量不含有值，当程序出现这个值时，说明出现了比较严重的问题，或者程序的设计不合理。</p><p>可以通过将变量的值设置为 null 来清空变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars=<span class="literal">null</span>;</span><br><span class="line">person=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h4><p>当声明新变量时。可以使用关键词“new”来声明其类型。</p><h3 id="3、三大结构"><a href="#3、三大结构" class="headerlink" title="3、三大结构"></a>3、三大结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><h4 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h4><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><h3 id="4、对象和结构"><a href="#4、对象和结构" class="headerlink" title="4、对象和结构"></a>4、对象和结构</h3><h4 id="对象概念"><a href="#对象概念" class="headerlink" title="对象概念"></a>对象概念</h4><p>真实生活中，有很多东西可以抽象成一个对象，比如一辆车，有品牌、重量、颜色、排放量等等。一个人有身高、体重、性别、爱好等属性。</p><p>对象也是一个变量，但对象可以包含多个值，每个值以name:value来呈现（）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;<span class="attr">name</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="number">500</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;<span class="comment">//创建</span></span><br></pre></td></tr></table></figure><p>可以说 “JavaScript 对象是变量的容器”。</p><p>但是，我们通常认为 “JavaScript 对象是键值对的容器”。</p><p>键值对通常写法为 <strong>name : value</strong> (键与值以冒号分割)。</p><p>键值对在 JavaScript 对象通常称为 <strong>对象属性</strong>。</p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>对象的方法定义了一个函数，并作为对象的属性存储。</p><p>对象方法通过添加 () 调用 (作为一个函数)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = person.<span class="title function_">fullName</span>();</span><br></pre></td></tr></table></figure><p>不加括号访问将会返回定义函数的字符串。</p><p>创建对象方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methodName : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 代码 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=objectName.<span class="title function_">methodName</span>()</span><br><span class="line"><span class="comment">//访问</span></span><br></pre></td></tr></table></figure><h3 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h3><h4 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h4><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数参数只在函数内起作用，是局部变量。</p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><h3 id="6、变量和常量"><a href="#6、变量和常量" class="headerlink" title="6、变量和常量"></a>6、变量和常量</h3><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>变量在函数内声明，变量为局部变量，具有局部作用域。</p><p>局部变量：只能在函数内部访问。</p><p>变量在函数外定义，即为全局变量。</p><p>全局变量有 <strong>全局作用域</strong>: 网页中所有脚本和函数均可使用。</p><p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</p><p>以下实例中 carName 在函数内，但是为全局变量。</p><h4 id="变量生存期"><a href="#变量生存期" class="headerlink" title="变量生存期"></a>变量生存期</h4><p>JavaScript 变量生命周期在它声明时初始化。</p><p>局部变量在函数执行完毕后销毁。</p><p>全局变量在页面关闭后销毁。</p><h4 id="未声明变量复制和全局变量"><a href="#未声明变量复制和全局变量" class="headerlink" title="未声明变量复制和全局变量"></a>未声明变量复制和全局变量</h4><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><h4 id="html中的全局变量"><a href="#html中的全局变量" class="headerlink" title="html中的全局变量"></a>html中的全局变量</h4><p>在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;孤山的js笔记&quot;&gt;&lt;a href=&quot;#孤山的js笔记&quot; class=&quot;headerlink&quot; title=&quot;孤山的js笔记&quot;&gt;&lt;/a&gt;孤山的js笔记&lt;/h1&gt;&lt;p&gt;如果说html是网页的身体，css是网页的衣服，那么，js就是网页的行为。有了js，网页就多了一些活</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>这是过渡用博客</title>
    <link href="https://gushan233.xyz/%E8%BF%99%E6%98%AF%E8%BF%87%E6%B8%A1%E7%94%A8%E5%8D%9A%E5%AE%A2/"/>
    <id>https://gushan233.xyz/%E8%BF%99%E6%98%AF%E8%BF%87%E6%B8%A1%E7%94%A8%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-08-02T09:37:13.000Z</published>
    <updated>2022-08-02T10:04:56.098Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>这个不用看</title>
    <link href="https://gushan233.xyz/hello-world/"/>
    <id>https://gushan233.xyz/hello-world/</id>
    <published>2022-08-02T07:56:22.326Z</published>
    <updated>2022-08-02T11:16:33.698Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="-hexo-" scheme="https://gushan233.xyz/categories/hexo/"/>
    
    
    <category term="-hexo-" scheme="https://gushan233.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>孤山的javafx教程——javafx简单入门</title>
    <link href="https://gushan233.xyz/javafx%E6%95%99%E7%A8%8B/"/>
    <id>https://gushan233.xyz/javafx%E6%95%99%E7%A8%8B/</id>
    <published>2022-07-13T04:00:00.000Z</published>
    <updated>2022-08-15T02:24:34.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="孤山的javafx教程——javafx简单入门"><a href="#孤山的javafx教程——javafx简单入门" class="headerlink" title="孤山的javafx教程——javafx简单入门"></a>孤山的javafx教程——javafx简单入门</h1><h2 id="java-fx是什么"><a href="#java-fx是什么" class="headerlink" title="java fx是什么"></a>java fx是什么</h2><p>是java实现图形界面的一种方式，其他还有java的awt、swing，但是逐渐被淘汰。</p><p>javafx可以实现逻辑和样式的分离，可以使用xml和css来编写样式。</p><p>在学习之前请确保你已经熟练掌握面向对象、包装类、枚举、注解、匿名对象等内容的概念和使用。</p><h2 id="java-11及以后使用javafx的方法"><a href="#java-11及以后使用javafx的方法" class="headerlink" title="java 11及以后使用javafx的方法"></a>java 11及以后使用javafx的方法</h2><h3 id="jdk-11-的使用"><a href="#jdk-11-的使用" class="headerlink" title="jdk 11+的使用"></a>jdk 11+的使用</h3><p>自从java11以后，jdk已经不内置javafx库，已交给开源社区管理，所以我们需要自己导入。</p><p>可以到这个网址去下载 jar 包。注意下载的类型是sdk。</p><p><a href="https://gluonhq.com/products/javafx/">gluonhq.com</a></p><p>使用maven的同学可以使用以下语句导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjfx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javafx-controls<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>19-ea+8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>本教程使用的java版本是18，因此可能与java8的写法有所出入。</p><h3 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h3><p><a href="https://docs.oracle.com/javafx/2/api/index.html">老版本的fx文档</a></p><p><a href="https://openjfx.io/javadoc/18/">新版本的fx文档</a></p><h2 id="fx基本"><a href="#fx基本" class="headerlink" title="fx基本"></a>fx基本</h2><h3 id="java-fx的两种写法和helloworld"><a href="#java-fx的两种写法和helloworld" class="headerlink" title="java fx的两种写法和helloworld"></a>java fx的两种写法和helloworld</h3><p>第一种写法把fx app实现方法和main方法写在一个类里面，在java 11之后这个方式就失效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javafx.application.Application;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_1helloJfx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        launch(args);  <span class="hljs-comment">//调用start</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        primaryStage.setTitle(<span class="hljs-string">&quot;javafx&quot;</span>); <span class="hljs-comment">//设置标题</span><br>        primaryStage.show(); <span class="hljs-comment">//展示窗口</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法把两个方法分开放置，在launch里面传入有start方法类的反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javafx.application.Application;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Application.launch(Window.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javafx.application.Application;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage arg0)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        arg0.show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="javafx的分层"><a href="#javafx的分层" class="headerlink" title="javafx的分层"></a>javafx的分层</h3><p>一个javafx程序有三层，最外面的是Stage层，一个Stage就是一个独立的窗口。</p><p>在往里是Scene层，一个Scene就是一个窗口内部的一个状态。</p><p>在往里就是一个一个的node节点，节点可以是按钮、标签、文本等组件、</p><h3 id="javafx的生命周期"><a href="#javafx的生命周期" class="headerlink" title="javafx的生命周期"></a>javafx的生命周期</h3><p>任何一个事物都有产生、发展、消亡的过程，人是这样，程序也不例外。</p><p>javafx的生命周期分为init、start和stop，分别是初始化，正在运行和结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;init()：&quot;</span> + Thread.currentThread().getName());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println(<span class="hljs-string">&quot;运行&quot;</span>);<br>    primaryStage.show();<br>    System.out.println(<span class="hljs-string">&quot;start()：&quot;</span> + Thread.currentThread().getName());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;stop()：&quot;</span> + Thread.currentThread().getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后发现init是一个独立的线程，start和stop同属一个JavaFX Application Thread线程，关闭窗口后就会进入stop，我们可以在这个方法里放一些停止连接之类的函数。</p><h2 id="fx窗口"><a href="#fx窗口" class="headerlink" title="fx窗口"></a>fx窗口</h2><h3 id="Stage类"><a href="#Stage类" class="headerlink" title="Stage类"></a>Stage类</h3><p>一个Stage类代表一个窗口，我们可以不使用方法提供的Stage，再写一个.</p><p>另外，Stage的setHeight()和setWidth()方法用来设置窗口的宽高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">Stage</span> <span class="hljs-variable">stage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stage</span>();<br><br>       stage.setHeight(<span class="hljs-number">500</span>);<br>       stage.setWidth(<span class="hljs-number">500</span>);<br>       <br>       stage.show();<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>Stage类的其他方法如下表所示</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>setMaxHeight(int);</td><td>窗口最大高度</td></tr><tr><td>setMaxWidth(int);</td><td>窗口最大宽度</td></tr><tr><td>setResizable(boolean);</td><td>是否允许改变大小</td></tr><tr><td>setMinHeight(int);</td><td>窗口最小高度</td></tr><tr><td>setMinWidth(int);</td><td>窗口最小宽度</td></tr><tr><td>setMaximized(boolean);</td><td>是否最大化</td></tr><tr><td>setIconified(boolean);</td><td>是否最小化</td></tr><tr><td>setFullScreen(boolean);</td><td>是否全屏</td></tr><tr><td>setAlwaysOnTop(boolean);</td><td>窗口是否保持置顶</td></tr><tr><td>setY(int)</td><td>窗口出生距离屏幕上面的高度</td></tr><tr><td>setX(int)</td><td>窗口出生举例屏幕左边的宽度</td></tr><tr><td>primaryStage.setOpacity();</td><td>透明度</td></tr><tr><td>setTitle(String)</td><td>设置窗口标题</td></tr><tr><td>initStyle(StageStyle);</td><td>设置窗口样式，只要知道三个常用的函数，StageStyle.DECORATED是正常，StageStyle.UTILITY没有最大最小化，StageStyle.TRANSPARENT是透明就行；</td></tr><tr><td>setScene(Scene)</td><td>给窗口设置场景</td></tr><tr><td>close();</td><td>关闭窗口</td></tr></tbody></table><h3 id="Srage宽度高度监听和位置监听"><a href="#Srage宽度高度监听和位置监听" class="headerlink" title="Srage宽度高度监听和位置监听"></a>Srage宽度高度监听和位置监听</h3><p>可以用监听来做界面自适应之类的东西。</p><h4 id="窗口大小监听"><a href="#窗口大小监听" class="headerlink" title="窗口大小监听"></a>窗口大小监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Stage</span> <span class="hljs-variable">stage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stage</span>();<br><br>        stage.heightProperty().addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeListener</span>&lt;Number&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changed</span><span class="hljs-params">(ObservableValue&lt;? extends Number&gt; arg0, Number arg1, Number arg2)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;高度 = &quot;</span>+arg2.doubleValue());<br>            &#125;<br>            <br>        &#125;);<br><br>        stage.widthProperty().addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeListener</span>&lt;Number&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changed</span><span class="hljs-params">(ObservableValue&lt;? extends Number&gt; arg0, Number arg1, Number arg2)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;宽度 = &quot;</span>+arg2.doubleValue());<br>            &#125;<br>            <br>        &#125;);    <br>        stage.show();<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="窗口位置监听"><a href="#窗口位置监听" class="headerlink" title="窗口位置监听"></a>窗口位置监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <br>       primaryStage.setY(<span class="hljs-number">100</span>);<br>       primaryStage.setX(<span class="hljs-number">100</span>);<br>       primaryStage.setWidth(<span class="hljs-number">200</span>);<br>       primaryStage.setHeight(<span class="hljs-number">200</span>);<br><br>       primaryStage.xProperty().addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeListener</span>&lt;Number&gt;() &#123;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changed</span><span class="hljs-params">(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue)</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;举例屏幕左边有 = &quot;</span>+newValue.doubleValue()+<span class="hljs-string">&quot; px&quot;</span>);<br>           &#125;<br><br>       &#125;);<br><br>       primaryStage.yProperty().addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeListener</span>&lt;Number&gt;() &#123;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changed</span><span class="hljs-params">(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue)</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;举例屏幕上面有 = &quot;</span>+newValue.doubleValue()+<span class="hljs-string">&quot; px&quot;</span>);<br>           &#125;<br>       &#125;);<br>      <br>       primaryStage.show();<br><br></code></pre></td></tr></table></figure><h3 id="窗口图标设置"><a href="#窗口图标设置" class="headerlink" title="窗口图标设置"></a>窗口图标设置</h3><p>在对应的包下放置文件，然后在getIcons的add方法里面填写相对路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.javafx;<br><br><span class="hljs-keyword">import</span> javafx.application.Application;<br><span class="hljs-keyword">import</span> javafx.scene.image.Image;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        primaryStage.getIcons().add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>(<span class="hljs-string">&quot;com/javafx/ico-01.png&quot;</span>));<br><br>        stage.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子窗口"><a href="#子窗口" class="headerlink" title="子窗口"></a>子窗口</h3><p>可以用initOwner()方法来设置一个窗口的父窗口，子窗口不关父窗口不会响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 模态化窗口。</span><br><br>    <span class="hljs-type">Stage</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stage</span>();<br>    s1.setTitle(<span class="hljs-string">&quot;s1&quot;</span>);<br><br>    <span class="hljs-type">Stage</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stage</span>();<br>    s2.setTitle(<span class="hljs-string">&quot;s2&quot;</span>);<br>    <span class="hljs-comment">// s1有s2;</span><br>    s2.initOwner(s1);<br><br>    s1.show();<br>    s2.show();<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Scene类"><a href="#Scene类" class="headerlink" title="Scene类"></a>Scene类</h2><p>在之前的练习中你可能发现了，窗口放大或缩小后，有些地方变成黑色，就是因为还没有添加一个Scene场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Group</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>();<br><span class="hljs-type">Scene</span> <span class="hljs-variable">scene</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scene</span>(group); <span class="hljs-comment">//创建一个场景</span><br>primaryStage.setScene(scene);<span class="hljs-comment">//给窗口设置场景</span><br></code></pre></td></tr></table></figure><p>创建一个场景需要传入一个参数，这个参数可以是一个布局，也可以是一个控件。</p><p>group是控件的集合，本身不是布局。</p><h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><h3 id="添加组件的方法"><a href="#添加组件的方法" class="headerlink" title="添加组件的方法"></a>添加组件的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">布局或集合组件.getChildren().add(组件对象<span class="hljs-number">1</span>); <span class="hljs-comment">//添加一个组件</span><br>布局或集合组件.getChildren().addAll(组件对象<span class="hljs-number">1</span>, 组件对象<span class="hljs-number">2</span>); <span class="hljs-comment">//添加多个组件</span><br></code></pre></td></tr></table></figure><h3 id="常用组件添加"><a href="#常用组件添加" class="headerlink" title="常用组件添加"></a>常用组件添加</h3><p>常用信息输出组件</p><table><thead><tr><th>Label()</th><th>标签</th></tr></thead><tbody><tr><td>Text()</td><td>文本</td></tr><tr><td>TextFlow()</td><td>文本域，fx8版本后出现</td></tr><tr><td>ImageView</td><td>图片框</td></tr><tr><td>ProgressBar</td><td>进度条</td></tr></tbody></table><p>常用控制组件</p><table><thead><tr><th>Button()</th><th>按钮</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>常用信息输入组件</p><table><thead><tr><th>TextField()</th><th>文本单行输入框</th></tr></thead><tbody><tr><td>TextField()</td><td>文本多行输入域</td></tr><tr><td>RadioButton()</td><td>单选按钮</td></tr><tr><td>checkBox()</td><td>多选按钮</td></tr><tr><td>PasswordField()</td><td>密码框</td></tr><tr><td>slider()</td><td>滑条</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.javafx;<br><br><span class="hljs-keyword">import</span> javafx.application.Application;<br><span class="hljs-keyword">import</span> javafx.scene.Group;<br><span class="hljs-keyword">import</span> javafx.scene.Scene;<br><span class="hljs-keyword">import</span> javafx.scene.control.Button;<br><span class="hljs-keyword">import</span> javafx.scene.control.CheckBox;<br><span class="hljs-keyword">import</span> javafx.scene.control.Label;<br><span class="hljs-keyword">import</span> javafx.scene.control.PasswordField;<br><span class="hljs-keyword">import</span> javafx.scene.control.ProgressBar;<br><span class="hljs-keyword">import</span> javafx.scene.control.RadioButton;<br><span class="hljs-keyword">import</span> javafx.scene.control.TextArea;<br><span class="hljs-keyword">import</span> javafx.scene.control.TextField;<br><span class="hljs-keyword">import</span> javafx.scene.image.Image;<br><span class="hljs-keyword">import</span> javafx.scene.image.ImageView;<br><span class="hljs-keyword">import</span> javafx.scene.layout.FlowPane;<br><span class="hljs-keyword">import</span> javafx.scene.text.Text;<br><span class="hljs-keyword">import</span> javafx.scene.text.TextFlow;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        <span class="hljs-type">Button</span> <span class="hljs-variable">btn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;b1&quot;</span>);<br>        Label lab=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(<span class="hljs-string">&quot;标签&quot;</span>);<br>        Text t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;文本。。。&quot;</span>);<br>        Text t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>        t2.setText(<span class="hljs-string">&quot;文本2。。。&quot;</span>);<br><br>        TextFlow tf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextFlow</span>();<br>        tf.getChildren().addAll(t1,t2);<br>        <br>        ProgressBar pb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProgressBar</span>();<br>        pb.setProgress(<span class="hljs-number">0.25</span>);<br>        ImageView iv=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageView</span>();<br>        iv.setImage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>(<span class="hljs-string">&quot;com/javafx/ico-01.png&quot;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>));<br><br>        RadioButton rb1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RadioButton</span>();<br>        RadioButton rb2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RadioButton</span>();<br>        rb2.setLayoutX(<span class="hljs-number">20</span>);<br>        CheckBox cb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckBox</span>();<br>        cb.setLayoutX(<span class="hljs-number">40</span>);<br>        Group group=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>();<br>        group.getChildren().addAll(rb1,rb2,cb);<br><br>        TextField tfIn=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>();<br>        TextArea ta=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextArea</span>();<br>        PasswordField psf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordField</span>();<br><br>        FlowPane pane=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowPane</span>();<br>        pane.getChildren().addAll(btn,lab,tf,pb,iv,group,tfIn,ta,psf);<br><br><br>        Scene scene=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scene</span>(pane);<br>        <br>        primaryStage.setScene(scene);<br>        primaryStage.setY(<span class="hljs-number">100</span>);<br>        primaryStage.setX(<span class="hljs-number">100</span>);<br>        primaryStage.setWidth(<span class="hljs-number">1000</span>);<br>        primaryStage.setHeight(<span class="hljs-number">600</span>);<br>        primaryStage.show();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>常用组件通用方法</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局我不去讲，请自行了解。这些布局之间可以互相嵌套，就像html里面的div一样。</p><table><thead><tr><th align="center">S.No</th><th align="center">形状和描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="https://iowiki.com/javafx/layout_panes_hbox.html">HBox</a>HBox布局将应用程序中的所有节点排列在一个水平行中。</td></tr><tr><td align="center">2</td><td align="center"><a href="https://iowiki.com/javafx/layout_panes_vbox.html">VBox</a>VBox布局将我们应用程序中的所有节点排列在一个垂直列中。</td></tr><tr><td align="center">3</td><td align="center"><a href="https://iowiki.com/javafx/layout_borderpane.html">BorderPane</a>边框窗格布局将应用程序中的节点排列在顶部，左侧，右侧，底部和中心位置。</td></tr><tr><td align="center">4</td><td align="center"><a href="https://iowiki.com/javafx/layout_stackpane.html">StackPane</a>堆栈窗格布局将应用程序中的节点排列在另一个上面，就像在堆栈中一样。</td></tr><tr><td align="center">5</td><td align="center"><a href="https://iowiki.com/javafx/layout_panes_textflow.html">TextFlow</a>文本流布局在单个流中排列多个文本节点。</td></tr><tr><td align="center">6</td><td align="center"><a href="https://iowiki.com/javafx/layout_anchorpane.html">AnchorPane</a>“锚点”窗格布局将应用程序中的节点锚定在距窗格特定距离处。</td></tr><tr><td align="center">7</td><td align="center"><a href="https://iowiki.com/javafx/layout_tilepane.html">TilePane</a>Tile窗格布局以均匀大小的tile的形式添加应用程序的所有节点。</td></tr><tr><td align="center">8</td><td align="center"><a href="https://iowiki.com/javafx/layout_gridpane.html">GridPane</a>网格窗格布局将应用程序中的节点排列为行和列的网格。</td></tr><tr><td align="center">9</td><td align="center"><a href="https://iowiki.com/javafx/layout_flowpane.html">FlowPane</a>流窗格布局包装流中的所有节点。</td></tr></tbody></table><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>在所有节点上，都可以添加监听，以下是所有节点都通用的监听事件。</p><h3 id="单击"><a href="#单击" class="headerlink" title="单击"></a>单击</h3><p>方式1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.javafx;<br><br><span class="hljs-keyword">import</span> javafx.application.Application;<br><span class="hljs-keyword">import</span> javafx.event.ActionEvent;<br><span class="hljs-keyword">import</span> javafx.scene.Scene;<br><span class="hljs-keyword">import</span> javafx.scene.control.Button;<br><span class="hljs-keyword">import</span> javafx.scene.layout.FlowPane;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        <span class="hljs-type">Button</span> <span class="hljs-variable">btn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;b1&quot;</span>);<br>        btn.setOnAction(<span class="hljs-keyword">new</span> <span class="hljs-title class_">javafx</span>.event.EventHandler&lt;ActionEvent&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>                <span class="hljs-type">Button</span> <span class="hljs-variable">bu</span> <span class="hljs-operator">=</span> (Button) event.getSource();<br><br>                System.out.println(bu.getText() + <span class="hljs-string">&quot;单击&quot;</span>);<br>            &#125;<br>        &#125;); <br><br>        FlowPane pane=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowPane</span>();<br>        pane.getChildren().add(btn);<br><br>        Scene scene=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scene</span>(pane);<br>        <br>        primaryStage.setScene(scene);<br>        primaryStage.setWidth(<span class="hljs-number">500</span>);<br>        primaryStage.setHeight(<span class="hljs-number">500</span>);<br>        primaryStage.show();<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双击"><a href="#双击" class="headerlink" title="双击"></a>双击</h3><p>这个方法也可以改成单击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java&#123;">package com.javafx;<br><br>import javafx.application.Application;<br>import javafx.event.EventHandler;<br>import javafx.scene.Scene;<br>import javafx.scene.control.Button;<br>import javafx.scene.input.MouseButton;<br>import javafx.scene.input.MouseEvent;<br>import javafx.scene.layout.FlowPane;<br>import javafx.stage.Stage;<br><br>public class Window extends Application&#123;<br>    @Override<br>    public void start(Stage primaryStage) throws Exception &#123;<br><br><br>        Button btn = new Button(&quot;b1&quot;);<br>        btn.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler&lt;MouseEvent&gt;() &#123;<br><br>            @Override<br>            public void handle(MouseEvent arg0) &#123;<br>                System.out.println(&quot;鼠标按键 = &quot; + arg0.getButton().name());<br>                Button bu = (Button) arg0.getSource();<br>                //连续点击只有两次且用的是鼠标左键<br>                if(arg0.getClickCount() == 2 &amp;&amp;<br>                arg0.getButton().name().equals(MouseButton.PRIMARY.name()))&#123;<br>                    System.out.println(bu.getText()+&quot;双击&quot;);<br>                &#125;<br>        &#125;<br>            <br>            <br>        &#125;);<br>        FlowPane pane=new FlowPane();<br>        pane.getChildren().add(btn);<br><br>        Scene scene=new Scene(pane);<br>        <br>        primaryStage.setScene(scene);<br>        primaryStage.setWidth(200);<br>        primaryStage.setHeight(200);<br>        primaryStage.show();<br><br>    &#125;<br><br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>如果想监测到多个键同时按到，需要用另外一个方法，这个后面会讲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.javafx;<br><br><span class="hljs-keyword">import</span> javafx.application.Application;<br><span class="hljs-keyword">import</span> javafx.event.EventHandler;<br><span class="hljs-keyword">import</span> javafx.scene.Scene;<br><span class="hljs-keyword">import</span> javafx.scene.input.KeyCode;<br><span class="hljs-keyword">import</span> javafx.scene.input.KeyEvent;<br><span class="hljs-keyword">import</span> javafx.scene.layout.FlowPane;<br><span class="hljs-keyword">import</span> javafx.scene.text.Font;<br><span class="hljs-keyword">import</span> javafx.scene.text.Text;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span>&#123;<br>    <span class="hljs-keyword">public</span> Text text;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Stage primaryStage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        text=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;你按下了 “ ” 键。&quot;</span>);<br>        text.setFont(Font.font(<span class="hljs-number">25</span>));<br>        <br>        FlowPane pane=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowPane</span>();<br>        pane.getChildren().add(text);<br><br>        Scene scene=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scene</span>(pane);<br><br><br>        scene.setOnKeyPressed(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHandler</span>&lt;KeyEvent&gt;()&#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(KeyEvent arg0)</span> &#123;<br>                <span class="hljs-keyword">if</span> (arg0.getCode().getName().equals(KeyCode.A.getName())) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;A被按下&quot;</span>);<br>                &#125;<br>                text.setText(<span class="hljs-string">&quot;你按下了“&quot;</span>+arg0.getCode().getName()+<span class="hljs-string">&quot;”键。&quot;</span>);             <br>            &#125;   <br>        &#125;);<br>        primaryStage.setScene(scene);<br>        primaryStage.setWidth(<span class="hljs-number">300</span>);<br>        primaryStage.setHeight(<span class="hljs-number">100</span>);<br>        primaryStage.show();<br><br>    &#125;<br><br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;孤山的javafx教程——javafx简单入门&quot;&gt;&lt;a href=&quot;#孤山的javafx教程——javafx简单入门&quot; class=&quot;headerlink&quot; title=&quot;孤山的javafx教程——javafx简单入门&quot;&gt;&lt;/a&gt;孤山的javafx教程——java</summary>
      
    
    
    
    <category term="-java-" scheme="https://gushan233.xyz/categories/java/"/>
    
    
    <category term="-java-, -GUI-" scheme="https://gushan233.xyz/tags/java-GUI/"/>
    
  </entry>
  
  <entry>
    <title>java从helloworld到游戏开发（弃坑）</title>
    <link href="https://gushan233.xyz/java%E5%9F%BA%E7%A1%80%EF%BC%8C%E4%BB%8E%E2%80%9C%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C%E2%80%9D%E5%88%B0%E7%AE%80%E5%8D%95%E6%B8%B8%E6%88%8F/"/>
    <id>https://gushan233.xyz/java%E5%9F%BA%E7%A1%80%EF%BC%8C%E4%BB%8E%E2%80%9C%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C%E2%80%9D%E5%88%B0%E7%AE%80%E5%8D%95%E6%B8%B8%E6%88%8F/</id>
    <published>2022-07-03T09:30:00.000Z</published>
    <updated>2022-08-15T02:24:26.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java“基础“，从“你好世界”到简单游戏"><a href="#java“基础“，从“你好世界”到简单游戏" class="headerlink" title="java“基础“，从“你好世界”到简单游戏"></a>java“基础“，从“你好世界”到简单游戏</h1><h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><h2 id="java简介与我们的目标"><a href="#java简介与我们的目标" class="headerlink" title="java简介与我们的目标"></a>java简介与我们的目标</h2><h3 id="测试版前言"><a href="#测试版前言" class="headerlink" title="测试版前言"></a>测试版前言</h3><p>本文尚未完善，一些东西讲的不是很透，将来至少80%的内容要被重写。</p><h3 id="我与java"><a href="#我与java" class="headerlink" title="我与java"></a>我与java</h3><p>​印象中，我第一次接触java是在初中，当时是为了制作Minecraft的mod而去学习的，但是因为没有看懂mc forge的api、事件等看起来像天书的东西，所以放弃了（现在看起来也很懵233）。</p><p>​我最近才知道java在后端也有如此广泛的应用，虽然至今java在我眼里更多还是游戏方面的。</p><h3 id="java历史"><a href="#java历史" class="headerlink" title="java历史"></a>java历史</h3><p>​好了，说回正题，Java的原型刚出来那会是在1992年，那时候还叫做“Oak”语言，由詹姆斯·高斯林（James Gosling）主导开发，oak面向的主要方向是硬件嵌入，但是硬件厂商并没有买账。</p><p>​在1995年，sun公司想起了搁置很久的oka，此时正逢互联网蓬勃发展，此时世界各大it企业投入了很多在动态网页的开发上。而为硬件平台开发的oak本身就比较轻巧，而当时的网站就需要这种嵌入式程序。在那之后，oak改名为java（因为商标被抢住了）</p><p>​1996年1月，Sun公司发布了Java的第一个开发工具包<em>（JDK 1.0）</em>，这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。同年9月，约8.3万个网页应用了Java技术来制作。</p><p>​java1.4之后的一个版本，因为改动太大了，所以版本号不是1.5而改成了5.0，2009年的时候Oracle甲骨文公司收购了Sun公司。现在很多公司常用的是8.0。</p><p>​8.0之后，java商用要收费了，可以使用开源的openJdk，但是用openjdk的也要开源。</p><p>​历史就介绍到这里，过一下就行。</p><h3 id="做游戏为什么要学编程？"><a href="#做游戏为什么要学编程？" class="headerlink" title="做游戏为什么要学编程？"></a>做游戏为什么要学编程？</h3><p>我们这里说的游戏，是电子游戏，电子游戏就是在计算机或电力驱动的游戏机上运行的游戏。</p><p>要论广义的游戏，有很多，象棋、五子棋、躲猫猫、以及各种桌游还有地球ol这个数值平衡极差的游戏。</p><p>你不学编程，自己一个人可以做非电子游戏，比如桌游。也可以借助计算机上的工具做游戏，比如橙光、RPGmarker，Ue4的蓝图，但是能做的类型有限，能发挥利用计算机的空间也没这么大，但是也不乏佳作。</p><p>学了编程之后，你想实现什么效果就实现什么效果，不用考虑工具带来的限制，随心所欲，能充分利用计算机本身。能创造出新的游戏机制和体验。你也能窥见像RPGmarker这些工具的背后是什么样的原理，甚至自己设计一款引擎。</p><p>还有学习编程给你带来的重要的几点：逻辑思维和抽象。这两个能力不管是在现实中还是在游戏中都很有用。</p><p>。。。</p><h3 id="教程目标和适合人群"><a href="#教程目标和适合人群" class="headerlink" title="教程目标和适合人群"></a>教程目标和适合人群</h3><p>​我们这个教程的目标，是要用java去做一系列的简单游戏，虽然java不适合制作桌面端的游戏，但是每个语言都是有潜力的。</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ul><li>这个教程并不是零基础，建议对java有一定了解，到能在控制台用循环打印三角形的程度就可以开始看了。</li><li>对创作的热情&gt;&#x3D;玩游戏的热情</li><li>不介意自己一开始做出来的游戏很简陋甚至单调，前辈们就是这么过来的。</li><li>一切能靠自己的智慧和搜索引擎解决的问题都要自己解决，而且提问的时候说清楚问题是什么，你用了哪些方法来解决问题，为什么要解决这个问题。</li></ul><h4 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h4><ul><li>对游戏开发感兴趣的人但不知道从哪里开始的人</li><li>因为一些原因要学java但是对程序开发提不起兴趣的人</li><li>想探索java这门语言在游戏方面可能性的人</li></ul><p>​</p><p>​现在开始开发之旅吧。</p><h2 id="编程的本质和学习方法"><a href="#编程的本质和学习方法" class="headerlink" title="编程的本质和学习方法"></a>编程的本质和学习方法</h2><p>编程不能单单靠死学，掌握了以下的方法，你能以常人几倍的速度而且更快乐的搞定这些知识。</p><h4 id="知识输出"><a href="#知识输出" class="headerlink" title="知识输出"></a>知识输出</h4><p>有些人为什么学的很慢呢？是没有知识输出可能就是原因之一。</p><p>知识输出这个东西很早就有人知道，东方叫”教学相长“，西方叫”费曼技巧“，知识输出就是你学了什么东西，就要教别人（可以是直接现实中教，或写作、做视频并发布到公共平台、或者不看资料在大脑中想象教授的场景）学会这个东西。在教授的过程中如果卡壳了，那就是你的某个知识点没有学会，赶紧去补。而如果没有发现卡住的地方，你的已有知识技能也会更熟练。本文章就是本人知识输出的成果。</p><h4 id="作品和项目意识、问题导向"><a href="#作品和项目意识、问题导向" class="headerlink" title="作品和项目意识、问题导向"></a>作品和项目意识、问题导向</h4><p><strong>做出自己的作品并发布，能获得反馈，是在实践中提高自己</strong></p><p><strong>做项目会运用到你的各项能力，让你发现自己的薄弱处。</strong></p><p>私认为，“<strong>作品</strong>”更多是兴趣的体现，“<strong>项目</strong>”更多的目的是提高技能水平，为工作而准备的体现。两者都是<strong>知识输出的更高形式</strong>。这个意识要贯穿学习编程的全过程，因为只有这样持续获得反馈，知道哪里学的不行，知道为什么学某一个知识点，而且更有可能学完整个东西。</p><p>在做作品或者项目的时候，你很可能会碰上很多问题，在解决问题的过程中你也会成长。</p><p>所以，不管是在跟我的文章学，还是跟着别人的教程学，是学java还是画画，目的最好都是做一个自己的作品或者项目，而不是只是为了学会这个技能本身，同时，享受过程！</p><h4 id="计算思维和量化"><a href="#计算思维和量化" class="headerlink" title="计算思维和量化"></a>计算思维和量化</h4><p>计算思维是对万物进行程序抽象的思维，后面会慢慢讲到。</p><p>量化是对事物思考为一个个数值，只要受过九年义务教育，都能很快学会。类似开奶茶店有多少成本、万里长城有多少块砖这类问题，都要用量化的思维来解决。在游戏中的体现就是数值策划。</p><h4 id="模仿，微创新"><a href="#模仿，微创新" class="headerlink" title="模仿，微创新"></a>模仿，微创新</h4><p>模仿是快速成长的方式之一，</p><h4 id="编程和计算机的本质"><a href="#编程和计算机的本质" class="headerlink" title="编程和计算机的本质"></a>编程和计算机的本质</h4><p>编程，就是编写程序。</p><p>编写，可以用任何软件，记事本、work、集成ide</p><p>所有程序，包括网页、脚本、软件、操作系统等等</p><p>计算机软件里面的东西，无非就两种，<strong>数据</strong>和<strong>函数</strong>，在任何编程中，就只是对他们两个的操作。</p><p>数据，很简单，就是存储在你电脑和手机上的存储器里面的电子，其中是0和1的不断排列，建立起了我们如今的信息社会。</p><p>而编程的工作，就是编写函数去处理数据，函数就是一个接受输入参数，处理功能、输出结果的过程，这点计算机也一样</p><p>计算机的行为，也无非就三种，<strong>输入、计算和输出</strong>，比如我们在用键盘和鼠标来输入信息，计算机会处理这些信息，然后在屏幕上输出，任何现代计算机都逃不出这个规律。</p><p>举个例子，你跟你妈说，今晚想吃炸鸡，就是<strong>输入参数</strong>，你妈拿出鸡块裹粉油炸，就是<strong>处理</strong>，晚饭把炸鸡端到你面前，就是<strong>输出</strong>。</p><p>再举个例子，并不严谨哈，人。人获取食物和信息，这是输入。食物被消化，信息被思考，这是处理。说话写作做动作等，这是输出。</p><p>再从更大的视角看数据和函数：**$\color{blue}{宇宙}$**</p><p>宇宙中即有的物质就是数据，宇宙中的物理规律就是函数。你想想是不是怎么回事？</p><p>宇宙中的物质因为规律而组合分解，因为引力有些物质聚在一起而且聚集的非常多，发生了核裂变，形成了恒星。一些物质一般的聚集形成了星星。地球在很久以前因为一些物质凑巧聚在一起形成了”复制子“，函数生成了新的函数，而新函数以新的方式与物质发生反应，这就是生命。</p><p>这个宇宙函数正正好呀。引力大一点物质都坍缩在一起，失掉了可能性。引力小一点分子原子就彼此分离，恒星行星都不会形成，更别说生命了。</p><p>所以</p><p>我们在做任何编程时，都是在对数据和函数在做操作，无一例外。</p><p>在我们实际学习和创作时，我会反复提及上面的应用，让这些原理和方法伴随着你成长。</p><h2 id="信息源寻找"><a href="#信息源寻找" class="headerlink" title="信息源寻找"></a>信息源寻找</h2><h3 id="互联网的信息萎缩"><a href="#互联网的信息萎缩" class="headerlink" title="互联网的信息萎缩"></a>互联网的信息萎缩</h3><p>当代的中文互联网，萎缩了。</p><p>如果你在2017年之前用百度找点东西的话，可能能找到很多有用的。</p><p>但是如今的互联网，随着更多人的涌入、资本的介入等众多原因，越来越难以找到有用的信息了。</p><p>各大论坛纷纷倒闭，信息逐渐被各大平台瓜分。</p><p>因为大数据算法，越来越多人困在自己的信息茧房里。抱怨着怎么没有新鲜事了。其实新鲜事到处都有，只是缺少发现的机会。</p><p>有一种概念叫做死锁（大概是吧），就是人不知道自己还没有探索的东西时，认为自己知道。</p><p>大趋势我们抵挡不住，只能通过各种技巧来避免被侵蚀。</p><h3 id="避免的方法"><a href="#避免的方法" class="headerlink" title="避免的方法"></a>避免的方法</h3><h4 id="关掉算法推荐"><a href="#关掉算法推荐" class="headerlink" title="关掉算法推荐"></a>关掉算法推荐</h4><p>可能有部分软件提供了关闭算法推荐的选项，能关则关。</p><h4 id="少用百度和csdn"><a href="#少用百度和csdn" class="headerlink" title="少用百度和csdn"></a>少用百度和csdn</h4><p>百度至少第一页已经被垃圾广告和乱七八糟的信息占满了，很多情况下找一个软件搜索排行都能排到5、6行。这就导致有人想找“steam”却找到了”Steam游戏管家”，找“万能解码”还送了一个“电脑管家”。</p><p>至于csdn，代码之类肉眼可见的下降，想找一个功能的实现却发现在csdn上大家都是抄来抄去，复制粘贴上来都是错的。当然其中不乏好代码，但是还是有很多垃圾挡在眼前。</p><p>建议用bing、google取代百度搜索，用博客园和其他网站替代csdn，虽然避免不了看到狗屎代码和信息的可能性，但是也降低了。</p><h4 id="rss订阅"><a href="#rss订阅" class="headerlink" title="rss订阅"></a>rss订阅</h4><p>rss订阅是一种看博客和信息的好方式，至少在00年代的时候很流行。</p><h4 id="随机寻找"><a href="#随机寻找" class="headerlink" title="随机寻找"></a>随机寻找</h4><p>维基百科的随机页面、未登录账号的平台推荐等等，去哪些随机性比较大的地方探索一下。</p><h4 id="跨学科思维"><a href="#跨学科思维" class="headerlink" title="跨学科思维"></a>跨学科思维</h4><p>拿着锤子看什么都像钉子。有一项专业技能的确能让你吃上饭，但是能挣多少、是否能更好的面对自己的生活、如何规划未来、看清趋势、做好选择，对作品的剧情、风格的更多探索，都需要更多学科的学习。</p><p>这里推荐两本书《认知觉醒》和《穷查理宝典》</p><h2 id="计算机和编程相关知识预科"><a href="#计算机和编程相关知识预科" class="headerlink" title="计算机和编程相关知识预科"></a>计算机和编程相关知识预科</h2><p>计算机：计算机是输入计算并输出的机器。</p><p>手机：手机是便携式的计算机，不管是苹果系统还是安卓系统</p><p>内存：内存是工作台，计算机要工作的时候就要把数据（材料）和函数（工具）放在工作台上来使用。</p><p>编译器：有了编译器</p><p>强类型&#x2F;弱类型：强类型语言在声明变量的时候必须指明是什么类型的变量，而弱类型不用指明，两种各有优缺点，java是强类型语言。</p><p>JVM：java跨平台的重要支撑，java并没有着重开发在某个平台上的具体支持，而是让jvm虚拟机支持每一种设备，java程序并不直接在系统上跑，而是在虚拟机上运行。这就实现了“一次编写，到处运行”，让java程序遍布了世界上很多的设备。</p><p>。。。</p><h2 id="关于游戏开发"><a href="#关于游戏开发" class="headerlink" title="关于游戏开发"></a>关于游戏开发</h2><p>游戏，自古就存在，而当今游戏的形式、内容、玩法越来越丰富，但是我认为很多人的视野却越来越小，越来越狭隘。就我目之所及，都是王者、英雄联盟（手游）斗地主，cs、吃鸡、消消乐。其实优秀的游戏有很多：</p><p>传说之下、OSU、CLANNAD、文明5、风之旅人、粘粘世界、饥荒、孢子。。。。。。</p><p>游戏玩法也很多：fps、经营、沙盒、音游。。。</p><p>游戏形式也很多：电脑游戏、手机游戏、桌游、现实中的运动。。。</p><p>所以我们做游戏的，眼界一定要广阔，世界上好玩的东西有很多，只是缺少发现的机会和动机。苍白的人生经历很难碰撞出火花，玩过的游戏很少你也很难做出优秀的游戏。</p><h2 id="看一看数量可怜的基于java的知名游戏"><a href="#看一看数量可怜的基于java的知名游戏" class="headerlink" title="看一看数量可怜的基于java的知名游戏"></a>看一看数量可怜的基于java的知名游戏</h2><h3 id="minecraft-java版"><a href="#minecraft-java版" class="headerlink" title="minecraft java版"></a>minecraft java版</h3><h3 id="塞班系统上的游戏"><a href="#塞班系统上的游戏" class="headerlink" title="塞班系统上的游戏"></a>塞班系统上的游戏</h3><h3 id="召唤与合成（手游）"><a href="#召唤与合成（手游）" class="headerlink" title="召唤与合成（手游）"></a>召唤与合成（手游）</h3><h1 id="一、数据类型和变量-一个个盒子"><a href="#一、数据类型和变量-一个个盒子" class="headerlink" title="一、数据类型和变量 一个个盒子"></a>一、数据类型和变量 一个个盒子</h1><h2 id="1、不管怎样，先写这个"><a href="#1、不管怎样，先写这个" class="headerlink" title="1、不管怎样，先写这个"></a>1、不管怎样，先写这个</h2><h3 id="你好世界"><a href="#你好世界" class="headerlink" title="你好世界"></a>你好世界</h3><p>在此之前，你要做的准备：java环境（jdk8以上并配置好环境变量），基础开发环境（epliec或idea），如何安装的教程在网上有很多，请自行寻找。</p><p>在开始正式开发前，我想告诉你下面这句话。</p><p>理解不了没关系，先记着。</p><p>好了，开始写代码吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单路线文字游戏"><a href="#单路线文字游戏" class="headerlink" title="单路线文字游戏"></a>单路线文字游戏</h3><p>​之后运行，会在控制台显示“Hello world!”，这是很多人学编程的开始，毕竟一开始最好要搞出一些反馈才能更好的学习。本教程也是一样，尽量从做游戏的角度出发。我先不说上面两行代码是什么意思，我先带你做一个简陋的文字游戏，只要在加上三种语句，就可以做成一个控制台单路线文字游戏，来看！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Scanner next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String n=<span class="hljs-string">&quot;&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;今天是毕业仪式&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;那个女孩，我喜欢她很久了&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;她细腻、感性、特别，独立于人群中&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;她来了！&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;&#x27;嗯。。，邵志同学，你找我？&#x27;&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;&#x27;请收下！&#x27;，我递给她情书后飞快地跑掉&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;。。。&quot;</span>);<br>        n=next.nextLine();<br>        <span class="hljs-comment">//按照这种顺序可以继续添加    </span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>好吧，这也许仅仅是一个小说，不过之后就会有和玩家互动的部分。</p><p>此时，你可能会想背后的原理是什么，之后我们会一一教授。</p><p>之后，介绍一些知识吧。</p><p>这个public static void main(String[] args){括号里面的东西}，就是所有java程序运行的开始。</p><p>像System.out.println(“HelloWorld”);还有n&#x3D;next.nextLine();这样的一行，被我们称为一条语句，一条独立的语句必须在后面加分号。</p><p>System.out.println(“”);括号里面的内容会被输出到控制台上，文本要放进两个引号之间间，第4行和n&#x3D;next.nextLine();的目的是防止System.out.println(“”);输出的内容被一下子输出出来，让玩家按enter键慢慢看。</p><blockquote><p><strong>作业</strong></p></blockquote><p>找一个短小的故事，把文本自行分割，然后用上面的方式在控制台中展示出来。</p><p>就像这样，每次完成一个知识点的学习后，做点小作品出来。</p><h2 id="2、如何让你的游戏在别人的电脑上跑起来？"><a href="#2、如何让你的游戏在别人的电脑上跑起来？" class="headerlink" title="2、如何让你的游戏在别人的电脑上跑起来？"></a>2、如何让你的游戏在别人的电脑上跑起来？</h2><p>游戏做出来当然是给人玩的，那么，怎么让游戏在别人的电脑上也能顺利运行呢？</p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>​当你使用命令行或者ide辅助编译，在bin目录下就会生成class文件，但不是人人都写Java程序，而且都会命令行运行，所以我们要更进一步，把class文件打包成jar和exe文件。</p><h4 id="方法1-jar命令"><a href="#方法1-jar命令" class="headerlink" title="方法1 jar命令"></a>方法1 jar命令</h4><p>打开存储.class文件的目录，cmd运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jar cvf Hello.jar Hello.class // 格式：jar cvf 你要生成jar的名称.jar 字节码文件<br></code></pre></td></tr></table></figure><h4 id="方法2-eclipse"><a href="#方法2-eclipse" class="headerlink" title="方法2 eclipse"></a>方法2 eclipse</h4><p>右键你的工程序名，选择导出（Export）</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\v2-80056d66d34ce93f9998e9d1b19d3573_720w.jpg" alt="img" loading="lazy"></p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\v2-e24b403c73209a67ee6da72c323f3c9b_720w.jpg" alt="img" loading="lazy"></p><h4 id="方式3-Idea"><a href="#方式3-Idea" class="headerlink" title="方式3 Idea"></a>方式3 Idea</h4><p><strong>1.选中java项目，选择 File -&gt; Project Structure (快捷键：Ctrl+Alt+Shift+S)。</strong></p><p>​     <img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\936385-20170324110829908-1183384895.png" alt="img" loading="lazy"></p><p><strong>2.在弹出的窗口中左侧选中”Artifacts”，点击”+”选择jar，然后选择”from modules with dependencies”。</strong></p><p>   <img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\936385-20170324111100221-1885541880.png" alt="img" loading="lazy"></p><p><strong>3. 在配置窗口中配置”Main Class”，这儿选择一个入口java类（有main方法），完成后，点击OK，OK按钮。到这儿就完成了“Project Structure”的设置了。</strong></p><p>​        <img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\936385-20170324111615971-988592796.png" alt="img" loading="lazy"></p><p><strong>4.回到IDEA的主菜单，选择“Build - Build Artifacts”下的“Build”或者“Rebuild”即可生成最终的可运行的jar.</strong></p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\936385-20170324112351096-2104709641.png" alt="img" loading="lazy"></p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\936385-20170324112359299-1918077482.png" alt="img" loading="lazy"> </p><p>  <img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\936385-20170324112417377-425642829.png" alt="img" loading="lazy"></p><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><p>现在每个人的电脑上基本上都有C++或C#的运行环境，pc端的软件基本上都是用这两个语言来写的，而java不是玩mc的人或者开发者的电脑上，基本上都没有，所以我们要想办法兼容其他人的电脑。</p><h4 id="使用exe4j来生成exe文件"><a href="#使用exe4j来生成exe文件" class="headerlink" title="使用exe4j来生成exe文件"></a>使用exe4j来生成exe文件</h4><p>首先你要有一个能运行的jar文件。</p><p>然后下载一个exe4J软件：</p><p>下载地址：<a href="http://www.ej-technologies.com/download/exe4j/files">http://www.ej-technologies.com/download/exe4j/files</a></p><p>使用exe4J把jar包转成exe</p><p>（1）双击打开：exe4j Wizard.exe，第一步直接next</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310128045559408.png" alt="img" loading="lazy"></p><p>（2）选择 “JAR in EXE” mode</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310129346186426.png" alt="img" loading="lazy"></p><p>（3）选择导出地址</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310130435402804.png" alt="img" loading="lazy"></p><p>（4）选择应用类型等</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310132430876215.png" alt="img" loading="lazy"></p><p>（5）如果电脑环境的jdk是64位，则记得勾选下面这个</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310134536336732.png" alt="img" loading="lazy"></p><p>（6）选择jar包</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310136153527401.png" alt="img" loading="lazy"></p><p>（7）选择main函数</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310137593217738.png" alt="img" loading="lazy"></p><p>（8）选择运行时的jre版本</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310138493681414.png" alt="img" loading="lazy"></p><p>（9）选择要生成exe文件时依赖的jdk，可点击+号自己选择本地的文件夹</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310140058374486.png" alt="img" loading="lazy"></p><p>（10）接下来的都是next，最后点击 “Click here to start the application”生成应用</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310141447275942.png" alt="img" loading="lazy"></p><p>（11）生成的exe文件</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\310142397437999.png" alt="img" loading="lazy"></p><h4 id="更好的兼容"><a href="#更好的兼容" class="headerlink" title="更好的兼容"></a>更好的兼容</h4><p>就算转成了exe文件，别人的电脑没有jre，也不能运行。此时，有三种办法：</p><ol><li>把自己的程序连同jre安装包一起发给朋友，让朋友安装jre</li><li>写一个bat，程序本体和jre文件放在一个文件夹里面，之后bat转换为exe，别人可以运行bat文件就自动使用文件夹里面的jre打开jar包</li><li>偷偷在朋友的电脑里安装jre，然后发给Ta程序。</li></ol><p>这里介绍第2种方法。</p><p>bat，中文意思是批处理，</p><blockquote><p>作业：把上一次作业做的程序用上面的方法打包出来发给朋友玩，没有朋友的可以随便找一个平台发出来或者自己玩。。。</p></blockquote><h2 id="3、变量是一个个盒子"><a href="#3、变量是一个个盒子" class="headerlink" title="3、变量是一个个盒子"></a>3、变量是一个个盒子</h2><h3 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h3><p>​在开始我们的游戏制作之前，不可避免的要学习一些别的东西，变量就是其中之一。</p><p>​在计算机中，运行中的程序的数值和数据都存在变量里面，假设计算机的内存是仓库，变量像盒子一样存着数字、文本、图片等资源，来供运行中的程序使用。比如用数字类型的变量来存储血量、物攻等信息，用字符类型来存储对话信息等。</p><p>​因为java是强类型语言，我们在定义变量之前，必须说明这个变量是什么类型的，变量里数据的类型就是数据类型了。</p><p>​先来定义一个数字类型的变量并输出到控制台来演示吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果控制台里面出现了2，你把等于号后面更改成别的数运行后的数也会变。</p><p>此时你又会出现疑惑，int是什么？括号里面的双引号呢？</p><p>就这样先做一遍，然后带着结果找问题，就这样做中学。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>int是一种数据类型，属于数字类型中的整数类型，整数类型，顾名思义，这个变量盒子里面只能有整数。</p><p>同属整数类型的还有byte、short、long，区别就是里面数值范围的大小：</p><p>byte：-128~127</p><p>short：-32768 ~ 32767</p><p>int：-2,147,483,648 ~ 2,147,483,647</p><p>long：-9,223,372,036,854,775,808~9,223,372,036,854,775,807</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>System.out.println(b);<br></code></pre></td></tr></table></figure><p>之后看到这种代码，上面没有那两个东西的，直接丢进(String[] args){的括号里。</p><p>你又有疑惑了，这些整数类型的大小是怎么定的呢？</p><p>因为计算机的构成。你学过计算机基础就会知道计算机是二进制的(binary)，而上面这些数的范围，为了跟存储空间凑整，范围就是2的幂。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>跟在int之后的是变量名，在java中，不管是变量名还是其他事物的名字，都需要遵守标识符的命名规则，毕竟无规矩不成方圆，不遵守写的代码就乱七八糟。</p><p>标识符有四个命名规则</p><p>1、标识符由字母、数字、下划线（_）和美元符号组成。</p><p>2、标识符不能以数字开头</p><p>3、表示符的名字不能和关键字和保留字相同</p><p>4、标识符区分大小写，没有长度限制，坚持见名知意的原则</p><p>嗯，1和2很好理解，什么是关键字、保留字和见名知意呢？</p><p>关键字是java语言保留的，为其定义的特殊标识符，比如int、println、System，你一旦使用这些关键字当变量名，编译器就分不清哪个是哪个了。</p><p>保留字是java语言未来可能会转为关键字的单词，比如 var 、goto。</p><p>见名知意是指在标识符命名时，名字要能反应被定义者的作用、含义。比如我要新建一个变量存储血量，那变量名可以是 BloodNum。如果取个a之类的变量名，虽然不影响程序运行，但是到之后很可能忘记，别人看你的代码也会骂娘。</p><p>另外，标识符尽量用英语而不是用拼音，而且最好遵守一下驼峰命名法，驼峰命名法是第一个单词以小写字母开始，第二个单词后面的单词的第一个字母以大写开头，比如studentInfo、fileName、gameStart。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型有float、double，与整数类型的区别就是可以有小数点之后的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.33333</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.2222222222222</span>;<br></code></pre></td></tr></table></figure><h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><p>char 类型可以存储一个单一的 16 位 Unicode 字符，注意等于号后面是单引号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;好&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>System.out.println(c);<br></code></pre></td></tr></table></figure><p>String类型可以存一段文本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><p>以上的输出结果与我们写的第一个代码结果一样。</p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><h3 id="变量转型"><a href="#变量转型" class="headerlink" title="变量转型"></a>变量转型</h3><p>变量转型可以分为向上转型和强制转型</p><p>向上转型是自然而然的，就像byte转换成short，因为short的空间比byte大，所以转型的时候不会有数据丢失，short转int，float转double也是同理。</p><p>而如果将short转成byte，把double转成float的时候，就出错了，因为这样会损失精确度。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="什么是修饰符"><a href="#什么是修饰符" class="headerlink" title="什么是修饰符"></a>什么是修饰符</h4><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y&#x2F;N（<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc">说明</a>）</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><ul><li>static 修饰符，用来修饰类方法和类变量。</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li></ul><p>这两个会在以后讲：</p><ul><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li></ul><h1 id="二、让java酱加减乘除吧"><a href="#二、让java酱加减乘除吧" class="headerlink" title="二、让java酱加减乘除吧"></a>二、让java酱加减乘除吧</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>&#x3D;：用于让一个变量等于某个变量或常量。</p><h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><p>+、-、*、&#x2F;、%、++、–</p><p>+&#x3D;、-&#x3D;</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&#x3D;&#x3D;、！&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;、|、^、!、&amp;&amp;、||</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件？ 表达式1：表达式2；</p><h2 id="数学函数与密码机实现"><a href="#数学函数与密码机实现" class="headerlink" title="数学函数与密码机实现"></a>数学函数与密码机实现</h2><h3 id="数学函数与程序函数的区别与联系"><a href="#数学函数与程序函数的区别与联系" class="headerlink" title="数学函数与程序函数的区别与联系"></a>数学函数与程序函数的区别与联系</h3><h3 id="密码学简易入门和简易密码小程序"><a href="#密码学简易入门和简易密码小程序" class="headerlink" title="密码学简易入门和简易密码小程序"></a>密码学简易入门和简易密码小程序</h3><p>​密码学的最早起源还要追溯到古罗马事情，打仗的时候需要时常传递信息，而凯撒大帝不想让信息被敌人截获，于是发明出了凯撒密码，凯撒密码的原理是这样的：</p><p>​加密者将所有字母同时前移或后移x位数字，然后收到密码的人再反向移动x个字母，也就是移动-x个字母，就可获得原文。</p><h1 id="三、程序运行如流水"><a href="#三、程序运行如流水" class="headerlink" title="三、程序运行如流水"></a>三、程序运行如流水</h1><p>现实生活中待解决的事情千奇百怪，在计算机发明之后，想要计算机解决的事情也是各种各样。“如果”发生了…，“就要”…，“对于”…，就一直执行…。这是为了告诉计算机在特定条件下该做什么操作。</p><p>对于我们游戏开发也是如此，顺序、分支、循环，每个都必不可少，你在视觉小说里的选项，是分支结构。2d或3d人物的跑动动作，也是一个循环。其实学完这章我们就可以做很多的控制台游戏了，我会在这个章节准备大量的游戏实例给你。</p><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>程序的运行其实可以想成一条河流，截至现在，我们的程序其实都是一种结构，那就是顺序结构，河流中的水一直在朝一个方向流动。显然，这还不够。</p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>上次我们做了单路线视觉小说，但是大家应该都想做分支剧情，if就可以实现它。不过，在此之前要简陋介绍一下Scanner这个东西。</p><p>Scanner是java的输入类，类是一系列工具的集合，Scanner就是输入工具的集合，用于在控制台接收各种数据，使用之前先要新建一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure><p>其中next那部分是对象名，也要遵守<a href="###%E5%91%BD%E5%90%8D">标识符</a>的命名规则。先不用管“对象”是什么，先当成我们拿来了一堆工具并取了名，你就可以使用它们了。</p><p>新建对象时上面会出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br></code></pre></td></tr></table></figure><p>就先理解为工具不能散开，必须拿一个包，装起来才方便拿出来使用，这个操作就是把工具包拿来了。不然在java的仓库里面你很难找到工具。</p><p>下面这一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">n=next.nextLine();<br></code></pre></td></tr></table></figure><p>这条语句，我并没有让它接收实质的数据，只是想用它暂停，然后玩家能够按回车继续。在控制台这方面，我认为java做的没有python等语言好。</p><p>其他部分我们放到OOP哪个章节再说。</p><p>为了应付如果×××成立就要…，否则”就要……的需求，Java提供了if … else条件式。语法如下：</p><p>if（条件式）｛</p><p>描述句1；</p><p>}else if(条件式) {</p><p>描述句2；</p><p>}else{</p><p>}</p><p>上面的意思就是说：如果满足if里面的条件，就执行描述句1，否则跳过往下执行else if，如果else if里面的条件式满足，就执行描述句2,不然执行else，当上面的所有if语句都没有执行时，else才会执行。</p><p>if可以嵌套，一个if套一个if，想套多少套多少，只要你和上帝能看懂就行。</p><p>那么我们就给我们的视觉小说加上分支吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String n=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">byte</span> Flag1=<span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;今天是毕业仪式&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;那个女孩，我喜欢她很久了&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;她细腻、感性、特别，独立于人群中&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;她来了！&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;&#x27;嗯。。，邵志同学，你找我？&#x27;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1、递给他情书   2、逃跑&quot;</span>);<br>        Flag1= next.nextByte();<br><br>        <span class="hljs-keyword">if</span> (Flag1==<span class="hljs-number">1</span>)&#123;<br>            n=next.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;&#x27;请收下！&#x27;，我递给她情书后飞快地跑掉&quot;</span>);<br>            n=next.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;。。。&quot;</span>);<br>            n=next.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;5年后。。。&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;我和她坐在长椅上，享受下午的时光&quot;</span>);<br>            n=next.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;Good End&quot;</span>);<br>            n=next.nextLine();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Flag1==<span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;自此之后我就没有见过那个女孩&quot;</span>);<br>            n=next.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;早知道当初就该勇敢一点了。。。&quot;</span>);<br>            n=next.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;Bad End&quot;</span>);<br>            n=next.nextLine();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当然现实中的恋爱可没怎么简单。。。</p><p>这次我新定义了一个变量Flag1，用来记录游戏中的选项造成的影响，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">Flag1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>之后我让Scanner真正意义上接收了数据，让玩家输入0或1存到flag1变量里面。随后将Flag1交给if判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Flag1= next.nextByte();<br><br>       <span class="hljs-keyword">if</span> (Flag1==<span class="hljs-number">1</span>)&#123;<br>           ...<br></code></pre></td></tr></table></figure><p>此时会有问题，如果有玩家输入的不是1或2，而是0或其他的数，这个程序会怎么处理呢？</p><p>答案是，直接退出，因为这个程序没有考虑到玩家输入其他数的可能。</p><p>到下面的循环结构后，我们会解决这个问题。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch是判断结构的另一种形式，不知道是否让你想到任天堂的switch游戏机。</p><p>switch的中文意思是切换，它不像if，可以用逻辑运算符。他是根据变量的情况来判断该执行那个块，switch的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(x)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        描述句<span class="hljs-number">1</span>；<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        描述句<span class="hljs-number">2</span>；<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        描述句<span class="hljs-number">3</span>；<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> n:<br>        描述句n；<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>switch接收一个变量x，如果x等于1的话执行 描述句1，如果x等于2的话执行 描述句2，如果x等于n的话执行c 描述句n。如果上面都不成立，执行default，default是可选项。</p><p>break代表的是终止，为什么要加呢？因为不加的话case如果满足条件就会一直往下执行，会把每个case都判断一遍，就容易乱，而且我们一般要求switch执行一遍停止就行了。</p><p>下面我们用switch重写上面的那个视觉小说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String n=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">byte</span> Flag1=<span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;今天是毕业仪式&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;那个女孩，我喜欢她很久了&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;她细腻、感性、特别，独立于人群中&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;她来了！&quot;</span>);<br>        n=next.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;&#x27;嗯。。，邵志同学，你找我？&#x27;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1、递给他情书   2、逃跑&quot;</span>);<br>        Flag1= next.nextByte();<br><br>        <span class="hljs-keyword">switch</span> (Flag1)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;&#x27;请收下！&#x27;，我递给她情书后飞快地跑掉&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;。。。&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;5年后。。。&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;我和她坐在长椅上，享受下午的时光&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;Good End&quot;</span>);<br>                n=next.nextLine();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                System.out.println(<span class="hljs-string">&quot;自此之后我就没有见过那个女孩&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;早知道当初就该勇敢一点了。。。&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;Bad End&quot;</span>);<br>                n=next.nextLine();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果跟上一节的if运行结果一样。</p><p>switch建议判断固定值的时候用，比较易读，比如我们那个视觉小说的判断，if建议判断区间或范围的时候用，if能代替switch，但是switch不能代替if。</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>让我们想想我们之前的游戏都缺了什么？</p><p>“返回”吧。我们的游戏到结局后不是返回主菜单而是直接退出，如何解决这个问题呢？我们就要用到循环了。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while的结构是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>( 布尔表达式 ) &#123;<br>  <span class="hljs-comment">//循环内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要布尔表达式为true，里面的内容就会一直执行下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">10</span>)&#123;<br>            ++i;<br>            System.out.println(<span class="hljs-string">&quot;我饿了，这是第&quot;</span>+i+<span class="hljs-string">&quot;遍(*￣︿￣)&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;好好好，饭来了 w(ﾟДﾟ)w&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一种特殊情况，就是while里面的自变量没有变化，永远没有满足表达式的情况，这种情况成为死循环，我们要尽量避免死循环，一定要有打破循环的条件，看下面两个冤种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>     System.out.println(<span class="hljs-string">&quot;w(ﾟДﾟ)w 我被困住了！！！！&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">10</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;w(ﾟДﾟ)w 俺也一样&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面就为上面那个游戏写一个主菜单，当游戏结束时就返回主菜单，而不是直接退出。在主菜单可以输入0来退出游戏，顺便也把用户在选择时输入其他数字的情况也解决了。因为这个游戏还会反复用到，老是说“上面那个游戏”怪不方便的，所以就叫《邵志的爱情故事》吧。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> option=<span class="hljs-number">0</span>;<br>        String n=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">byte</span> Flag1=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(option!=<span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;——————————————————&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;|邵志的爱情故事|&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;——————————————————&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;1、开始游戏&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;2、退出&quot;</span>);<br>            option= next.nextInt();<br>            <span class="hljs-keyword">if</span> (option==<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//等于1时，开始游戏</span><br>                System.out.println(<span class="hljs-string">&quot;今天是毕业仪式&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;那个女孩，我喜欢她很久了&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;她细腻、感性、特别，独立于人群中&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;她来了！&quot;</span>);<br>                n=next.nextLine();<br>                System.out.println(<span class="hljs-string">&quot;&#x27;嗯。。，邵志同学，你找我？&#x27;&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;1、递给他情书   2、逃跑&quot;</span>);<br>                Flag1= next.nextByte();<br><br>               <span class="hljs-keyword">while</span> (Flag1!=<span class="hljs-number">1</span> &amp;&amp; Flag1!=<span class="hljs-number">2</span>)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;输入错误，请重新输入&quot;</span>);<br>                   System.out.println(<span class="hljs-string">&quot;1、递给他情书   2、逃跑&quot;</span>);<br>                   Flag1= next.nextByte();<br>                &#125;<br><br><br>                <span class="hljs-keyword">switch</span> (Flag1)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                        n=next.nextLine();<br>                        System.out.println(<span class="hljs-string">&quot;&#x27;请收下！&#x27;，我递给她情书后飞快地跑掉&quot;</span>);<br>                        n=next.nextLine();<br>                        System.out.println(<span class="hljs-string">&quot;。。。&quot;</span>);<br>                        n=next.nextLine();<br>                        System.out.println(<span class="hljs-string">&quot;5年后。。。&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;我和她坐在长椅上，享受下午的时光&quot;</span>);<br>                        n=next.nextLine();<br>                        System.out.println(<span class="hljs-string">&quot;Good End&quot;</span>);<br>                        n=next.nextLine();<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                        System.out.println(<span class="hljs-string">&quot;自此之后我就没有见过那个女孩&quot;</span>);<br>                        n=next.nextLine();<br>                        System.out.println(<span class="hljs-string">&quot;早知道当初就该勇敢一点了。。。&quot;</span>);<br>                        n=next.nextLine();<br>                        System.out.println(<span class="hljs-string">&quot;Bad End&quot;</span>);<br>                        n=next.nextLine();<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                option=<span class="hljs-number">0</span>; <span class="hljs-comment">//选择变量初始化</span><br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><p>do…while是while的另一种写法，while是先判断再执行，如果第一次判断是false，那么整个循环体里面的内容就不会执行。而do…while是先执行再判断，不管什么情况至少先执行一次，然后判断条件是否要再执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我饿了，这是第&quot;</span>+i+<span class="hljs-string">&quot;遍(*￣︿￣)&quot;</span>);<br>            i++;<br>        &#125;<span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;好好好，饭来了 w(ﾟДﾟ)w&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for是循环的另一种规范写法，与while不同，自增的部分可以放到括号里</p><h3 id="continue和break"><a href="#continue和break" class="headerlink" title="continue和break"></a>continue和break</h3><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>java方法是语句的集合。不知大家在生活中是否有分类的习惯，java的方法就是将执行不同语句的代码分开，从而让我们更易读懂，也更加规范。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><h3 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h3><ul><li><ol><li>使程序变得更简短而清晰。</li></ol></li><li><ol start="2"><li>有利于程序维护。</li></ol></li><li><ol start="3"><li>可以提高程序开发的效率。</li></ol></li><li><ol start="4"><li>提高了代码的重用性。</li></ol></li></ul><h3 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h3><p>方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</p><h3 id="方法的格式"><a href="#方法的格式" class="headerlink" title="方法的格式"></a>方法的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你以前学过类似c的语言，你会感到很熟悉。</p><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li><li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li></ul><p>看不懂也没关系，我接下来就进一步解释一下：</p><p>修饰符，这里可以填跟变量一样的修饰符，这里就先只填public，同项目任何地方都能访问，因为其他的修饰符我们需要在面向对象章节才能详解。</p><p>返回值类型：之前我们讲过计算机只有三个操作，输入、运算、输出。方法也是一个函数，只不过具体数值的输入和输出是可以忽略的，返回值就是方法的输出。</p><p>参数类型：如上，方法的输入。</p><p>方法体：方法具体执行的功能，这里应该遵从方法的“原子性”，就是一个方法只执行一个功能。</p><h3 id="方法在游戏和软件中的应用"><a href="#方法在游戏和软件中的应用" class="headerlink" title="方法在游戏和软件中的应用"></a>方法在游戏和软件中的应用</h3><p>在一个游戏中，会有很多“模块”，比如背包模块、主菜单模块、战斗模块、对话模块等，如果这些代码放在一处，会变得很乱，很难维护。方法得以让我们把不同功能的代码分开。</p><p>像之前的《爱情故事》，代码看起来就有点乱，我们加上方法，重写一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gameCon</span><span class="hljs-params">(Scanner next)</span> &#123;<br> <span class="hljs-type">int</span> Flag1=<span class="hljs-number">0</span>;<br> String n=<span class="hljs-string">&quot;&quot;</span>;<br> System.out.println(<span class="hljs-string">&quot;今天是毕业仪式&quot;</span>);<br>         n=next.nextLine();<br>         System.out.println(<span class="hljs-string">&quot;那个女孩，我喜欢她很久了&quot;</span>);<br>         n=next.nextLine();<br>         System.out.println(<span class="hljs-string">&quot;她细腻、感性、特别，独立于人群中&quot;</span>);<br>         n=next.nextLine();<br>         System.out.println(<span class="hljs-string">&quot;她来了！&quot;</span>);<br>         n=next.nextLine();<br>         System.out.println(<span class="hljs-string">&quot;&#x27;嗯。。，邵志同学，你找我？&#x27;&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;1、递给他情书   2、逃跑&quot;</span>);<br>         Flag1= next.nextByte();<br><br>        <span class="hljs-keyword">while</span> (Flag1!=<span class="hljs-number">1</span> &amp;&amp; Flag1!=<span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;输入错误，请重新输入&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;1、递给他情书   2、逃跑&quot;</span>);<br>            Flag1= next.nextByte();<br>         &#125;<br><br><br>         <span class="hljs-keyword">switch</span> (Flag1)&#123;<br>             <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                 n=next.nextLine();<br>                 System.out.println(<span class="hljs-string">&quot;&#x27;请收下！&#x27;，我递给她情书后飞快地跑掉&quot;</span>);<br>                 n=next.nextLine();<br>                 System.out.println(<span class="hljs-string">&quot;。。。&quot;</span>);<br>                 n=next.nextLine();<br>                 System.out.println(<span class="hljs-string">&quot;5年后。。。&quot;</span>);<br>                 System.out.println(<span class="hljs-string">&quot;我和她坐在长椅上，享受下午的时光&quot;</span>);<br>                 n=next.nextLine();<br>                 System.out.println(<span class="hljs-string">&quot;Good End&quot;</span>);<br>                 n=next.nextLine();<br>                 <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                 System.out.println(<span class="hljs-string">&quot;自此之后我就没有见过那个女孩&quot;</span>);<br>                 n=next.nextLine();<br>                 System.out.println(<span class="hljs-string">&quot;早知道当初就该勇敢一点了。。。&quot;</span>);<br>                 n=next.nextLine();<br>                 System.out.println(<span class="hljs-string">&quot;Bad End&quot;</span>);<br>                 n=next.nextLine();<br>                 <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <br>     <br>     &#125;<br> <br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span>&#123;<br> System.out.println(<span class="hljs-string">&quot;——————————————————&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;|邵志的爱情故事|&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;——————————————————&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;1、开始游戏&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;2、退出&quot;</span>);<br> &#125;<br> <br> <br> <br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> option=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span>(option!=<span class="hljs-number">2</span>)&#123;<br>        menu();<br>            option= next.nextInt();<br>            <br>            <span class="hljs-keyword">if</span> (option==<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//等于1时，开始游戏</span><br>                gameCon(next);<br>                option=<span class="hljs-number">0</span>; <span class="hljs-comment">//菜单选择变量初始化</span><br>                <br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(option==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="了解一下println"><a href="#了解一下println" class="headerlink" title="了解一下println"></a>了解一下println</h3><p>在之前，我们频繁用到了System.out.println();这条语句，那么它到底是什么来头呢？</p><p>跟我们前面说到的一样，这肯定是一个函数，函数输入一些东西，会进行一些处理，然后输出。</p><p>System.out.println();输入的是什么？</p><p>一串字符吧。字符输入进去之后的处理我们现在不提，之后输进去的字符就在控制台<strong>输出</strong>了。</p><p>这就是函数，而且之后学习的能实现具体东西的都是函数。</p><h2 id="结构化程序设计和被忘记的goto"><a href="#结构化程序设计和被忘记的goto" class="headerlink" title="结构化程序设计和被忘记的goto"></a>结构化程序设计和被忘记的goto</h2><p>​结构化程序设计由迪克斯特拉(E.W.dijkstra)在1969年提出，有以下几点特性</p><ul><li>模块化<ul><li>一个复杂问题，肯定是由若干稍简单的问题构成。<a href="https://baike.baidu.com/item/%E6%A8%A1%E5%9D%97">模块</a>化是把程序要解决的总目标分解为子目标，再进一步分解为具体的小目标，把每一个小目标称为一个模块。</li></ul></li><li>三种基本程序结构的组合<ul><li>使用顺序结构、分支结构和判断结构，限制使用goto。</li></ul></li><li>自顶向下、逐步求精<ul><li>程序设计时，应先考虑总体，后考虑细节；先考虑全局目标，后考虑局部目标。不要一开始就过多追求众多的细节，先从最上层总目标开始设计，逐步使问题具体化。</li><li>对复杂问题，应设计一些子目标作为过渡，逐步细化。</li></ul></li><li>单入口单出口</li></ul><p>总的来说可使程序结构良好、易读、易理解，但是也存在很多问题，之后会在面向对象和设计模式中解决。</p><h2 id="游戏实战"><a href="#游戏实战" class="headerlink" title="游戏实战"></a>游戏实战</h2><h1 id="四、常用工具-·-一"><a href="#四、常用工具-·-一" class="headerlink" title="四、常用工具 · 一"></a>四、常用工具 · 一</h1><h2 id="Typora和markdown，记录"><a href="#Typora和markdown，记录" class="headerlink" title="Typora和markdown，记录"></a>Typora和markdown，记录</h2><p>你写作的时候用什么软件？记事本？word？</p><p>不管你之前用的是什么，我都要给你介绍一种文件格式，他叫做markdown。为什么程序员很喜欢用呢？</p><p>有人发现当他们用Word或者别的文本编辑器写好一篇文章，兴高采烈地发布到博客、论坛、网站上时，发现格式完全乱了，于是需要花费大量的时间来重新排版，处理图片、缩进、字体、加粗、标题等。三番五次之后，开始发现文章写作可能只花了半小时，重新排版就花了十多分钟。更让人不悦的是，当我们要把同一篇文章发布到另一个网页上时，这样的排版还要重新做一次。</p><p>程序员习惯了非可视化界面，打字速度又超快，对他们而言使用鼠标操作意味着终断打字，是一个显著降低输入速度的行为，他们不喜欢在打字的时候被鼠标打断。一般来说文章的编写必然需要设置一定的格式：标题、加粗、行距、缩进、字体……这些一般都需要用鼠标在可视化界面上选择。</p><p>用不用md这个格式，看你的选择，并不强制，你觉得哪个格式好用就用哪个。</p><p>而md编辑器，我推荐Typora，我在这里写的所有文章都是Tyoira写的。</p><p>Typora的优点在于实时预览、导出格式丰富和主题自定义。</p><h2 id="git，github和gitee，版本"><a href="#git，github和gitee，版本" class="headerlink" title="git，github和gitee，版本"></a>git，github和gitee，版本</h2><p>​git是所有写程序的人都不得不了解的工具。git的主要作用是实现版本管理。</p><p>​举个简单的例子，当我们使用表格工作时，需要修改原来的方案表，但又不想把修改前的文件状态和内容给破坏掉，因为如果直接修改，万一修改的有问题，或者后悔修改了，那么以前的文件状态还在的话，我们可以直接使用前一个文件版本，所以他其实就用到了最简单的版本控制方法，那就是复制重命名；</p><p>​具体编程的过程也是一样的道理，其实就是一个反复编辑，不厌其烦的编辑的过程。而版本控制则通过记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>​因为我们在软件开发的最后阶段的会有很多个版本，而生成软件的源代码却往往只有一份，只是在最后编译生成的时候用到不同的部分，大部分代码还是共用的，所以往往需要版本控制。</p><p>版本控制有两种主流方式，git和svn。</p><p><strong>Git是分布式的，SVN是集中式的</strong></p><p>​这是 Git 和 SVN 最大的区别。若能掌握这个概念，两者区别基本搞懂大半。因为 Git 是分布式的，所以 Git 支持离线工作，在本地可以进行很多操作，包括接下来将要重磅推出的分支功能。而 SVN 必须联网才能正常工作。</p><p><strong>Git分支廉价，SVN分支昂贵</strong></p><p>​在版本管理里，分支是很常使用的功能。在发布版本前，需要发布分支，进行大需求开发，需要 feature 分支，大团队还会有开发分支，稳定分支等。在大团队开发过程中，常常存在创建分支，切换分支的需求。</p><p>​Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录。这个特性使 Git 的分支切换非常迅速，且创建成本非常低。</p><p>​而且 Git 有本地分支，SVN 无本地分支。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用 Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h3><p>​Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。但是Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。</p><p>​虽然大多数用户很乐于将 Eclipse 当作 Java 集成开发环境（IDE）来使用，但 Eclipse 的目标却不仅限于此。Eclipse 还包括插件开发环境，这个组件主要针对希望扩展 Eclipse 的软件开发人员，因为它允许他们构建与 Eclipse 环境无缝集成的工具。因此Eclipse还衍生出了Eclipse-c、Eclipse-Android等。</p><p>​eclipse在中国的使用人数日趋减少，可能是因为idea这个ide的兴起吧。</p><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>IDEA 全称 IntelliJ IDEA，也是是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能都是很不错的。</p><p>我也建议你们使用idea，尤其是初学者，实在是太智能了，能让你避免很多代码的错误。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库往后三章都不会用到，可以到时候再装。</p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><h3 id="DataGroup"><a href="#DataGroup" class="headerlink" title="DataGroup"></a>DataGroup</h3><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><h3 id="在线反编译工具"><a href="#在线反编译工具" class="headerlink" title="在线反编译工具"></a>在线反编译工具</h3><p>反编译是将已经编译过后的代码再还原成的、编译前的代码，便于学习研究。不过要注意版权，作者的许可范围。</p><p>在线反编译工具的优势在于，本地不需要安装任何软件，使用简单方便。</p><p>主要缺点是重要的非开源的公司项目的类文件或者 jar 包等通过使用第三方在线反编译平台有安全风险。</p><p>下面是两个不错的 Java 在线反编译网站。</p><p>第一个：<a href="https://link.zhihu.com/?target=http://www.decompiler.com/">http://www.decompiler.com/</a></p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\v2-55ff82a3823596b2bd138aefe58c67d7_720w.jpg" alt="img" loading="lazy"></p><p>第二个：<a href="https://link.zhihu.com/?target=http://www.javadecompilers.com/">http://www.javadecompilers.com/</a></p><p>该网站的主要优势在于有多种反编译器可供选择，大家也可以去对比这些 Java 反编译器的异同。</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\v2-357a3ec4afd747b39f28f90d4be56eea_720w.jpg" alt="img" loading="lazy"></p><h3 id="离线反编译工具"><a href="#离线反编译工具" class="headerlink" title="离线反编译工具"></a>离线反编译工具</h3><p>离线反编译工具的主要优势是安全性高，使用的体验更好。</p><p>同样推荐三款主流的离线反编译工具：IDEA 自带、 JD-GUI 、Luyten。</p><p>一、IDEA 自带的反编译工具，大家在 IDEA 中点击类文件即可使用。</p><p>二、JD-GUI<br><a href="https://link.zhihu.com/?target=http://java-decompiler.github.io/">JD-GUI</a> 是一个知名的反编译工具。 使用非常方便，下载后将类文件或者 jar 包直接拖动到界面即可。</p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\v2-61b16a6172355fd57553bb74dd90a855_720w.jpg" alt="img" loading="lazy"></p><p>三、Luyten</p><p><a href="https://link.zhihu.com/?target=https://github.com/deathmarine/Luyten">Luyten</a> 是另外一个不错的反编译工具。</p><p>下载地址：<a href="https://link.zhihu.com/?target=https://github.com/deathmarine/Luyten/releases">https://github.com/deathmarine/Luyten/releases</a></p><p><img src="C:\Users\Administrator.Bili-2021EFXMWA\Desktop\java基础，从“你好世界”到简单游戏.assets\v2-6fd7dcdfe9330581a63c31a0a39108de_720w.jpg" alt="img" loading="lazy"></p><p>四、arthas 反编译</p><p>​如果我们想通过反编译查看服务器上运行的代码是不是正确地，该怎么办呢？</p><p>有一个更好的工具：<a href="https://link.zhihu.com/?target=https://alibaba.github.io/arthas/">arthas</a>。</p><p>​可以使用 <a href="https://link.zhihu.com/?target=https://alibaba.github.io/arthas/jad.html">jad</a> 命令将 JVM 中运行的 class 的 byte code 反编译成 java 代码，便于理解业务。</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h1 id="五、OOP设计和背后的思维"><a href="#五、OOP设计和背后的思维" class="headerlink" title="五、OOP设计和背后的思维"></a>五、OOP设计和背后的思维</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><p>​我们在之前“程序如流水”这个章节里探讨了函数式程序的设计方法</p><p>​面向对象是一种程序设计方法，也被称为OOP，我们编写软件的目的常常是解决现实中的问题，或者写游戏的时候常常要抽象现实世界。面向对象就是很好的方式，它把事物分成属性和方法。</p><p>​属性就是该事物具有的特性、性质，比如汽车可以有颜色、排油量、最大速度这些属性，学生可以有名字、年龄、性别、成绩这些数学。</p><p>​方法就是这个事物可以干什么，汽车可以前进、停止、开启前灯光等。学生可以吃饭、学习等。</p><p><strong>三大结构和面向对象是最重要的章节，所有有面向对象特性的语言都无一例外。</strong></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><p>构造方法也被称作构造器，构造方法将在对象被创建的时候执行，用以初始化对象。如果有多个构造方法，会根据传入参数的不同来选择不同的构造方法。</p><p>下面是一个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">// 这个构造器仅有一个参数：name</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象这件事其实我们之前干过很多次，就是Scanner这个东西，它就是对象。</p><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><p>下面演示了一个对象创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String Hobbies;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age,String Hobbies)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        System.out.println(name+<span class="hljs-string">&quot;诞生了!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃了一顿饭&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;干了一次活&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        person gushan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">person</span>(<span class="hljs-string">&quot;孤山&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;创作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问实例对象和方法"><a href="#访问实例对象和方法" class="headerlink" title="访问实例对象和方法"></a>访问实例对象和方法</h3><p>用上面的代码，在main方法里面加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(gushan.name);<br>gushan.work();<br></code></pre></td></tr></table></figure><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><h3 id="包和import"><a href="#包和import" class="headerlink" title="包和import"></a>包和import</h3><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。在此之前我们都是用的java自带的类。</p><h3 id="用面向对象重写《爱情故事》"><a href="#用面向对象重写《爱情故事》" class="headerlink" title="用面向对象重写《爱情故事》"></a>用面向对象重写《爱情故事》</h3><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承介绍"><a href="#继承介绍" class="headerlink" title="继承介绍"></a>继承介绍</h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>比如在《愤怒的小鸟》中所有的鸟都能对建筑和猪造成伤害，《植物大战僵尸》中的所有僵尸都能走动（僵王除外233）。</p><p>拿现实举例子：</p><p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p><p>食草动物和食肉动物又是属于动物类。</p><p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p><p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p><p>继承需要用到extends关键字</p><p>继承的格式是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>&#125;<br> <br>class 子类 extends 父类 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>用伪代码举几个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">class 人 &#123;<br>&#125;<br> <br>class 孤山 extends 人 &#123;<br>&#125;<br><br><span class="hljs-comment">/////////////////////////</span><br>class 食物 &#123;<br>&#125;<br> <br>class 主食 extends 食物 &#123;<br>&#125;<br><br>class 米饭 extends 主食 &#123;<br>&#125;<br><span class="hljs-comment">/////////////////////////</span><br>class 人物 &#123;<br>    String 名字;<br>    <span class="hljs-type">int</span> 年龄;<br>    <span class="hljs-type">int</span> 金钱<br>    行走();<br>    对话();<br>&#125;<br> <br>class 玩家 extends 人物 &#123;<br>    操控();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">npc</span> extends 人物&#123;<br>    随机行走();<br>&#125;<br><br>class 商人npc <span class="hljs-keyword">extends</span> <span class="hljs-title class_">npc</span>&#123;<br>    卖物品();<br>    买物品();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="继承特性"><a href="#继承特性" class="headerlink" title="继承特性"></a>继承特性</h3><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。object真的是老祖宗！</p><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h2 id="特殊形式"><a href="#特殊形式" class="headerlink" title="特殊形式"></a>特殊形式</h2><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="有名内部类"><a href="#有名内部类" class="headerlink" title="有名内部类"></a>有名内部类</h4><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><h2 id="抽象世界"><a href="#抽象世界" class="headerlink" title="抽象世界"></a>抽象世界</h2><h1 id="六、存储结构-游戏和信息论"><a href="#六、存储结构-游戏和信息论" class="headerlink" title="六、存储结构 游戏和信息论"></a>六、存储结构 游戏和信息论</h1><h2 id="简单了解数据结构"><a href="#简单了解数据结构" class="headerlink" title="简单了解数据结构"></a>简单了解数据结构</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a>集合介绍</h3><p>集合是对象的容器，更好的存储对象，类似数组。</p><p>和数组的区别：</p><ul><li>数组长度固定，集合长度不固定。</li><li>数组能存储基本类型和引用类型，集合只能存储引用类型</li></ul><p> 所有集合都实现Collection这个接口，在之下又有两个接口</p><ul><li>List接口：有序、有下标、元素可重复</li><li>Set接口：无序、无下标、元素不能重复</li></ul><p>list接口下有ArrayList、LinkeList、Vector(不常用)</p><p>Set接口下有HashSet、TreeSet。</p><p>可以看成是另一种存储方式不同的箱子</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>代表一组任意的对象，无序、无下标、不能重复。</p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>          <span class="hljs-comment">//把给定的对象添加到当前集合中。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>             <span class="hljs-comment">// 清空集合中所有的元素。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span>       <span class="hljs-comment">//把给定的对象在当前集合中册除。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(E e)</span>     <span class="hljs-comment">//判断当前集合中是否包合给定的对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>         <span class="hljs-comment">//判断当前集合是否为空。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>                <span class="hljs-comment">//返回集合中元素的个数。</span><br><span class="hljs-keyword">public</span> Object[] toArray()        <span class="hljs-comment">//把集合中的元素,存储到数组中。</span><br></code></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="浅谈信息"><a href="#浅谈信息" class="headerlink" title="浅谈信息"></a>浅谈信息</h2><h2 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h2><h1 id="七、实用的类和方法-一"><a href="#七、实用的类和方法-一" class="headerlink" title="七、实用的类和方法 一"></a>七、实用的类和方法 一</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>游戏中需要用到许多数学的东西，尤其是动作游戏。类似三角函数、平方、虚数等等java早就内置在math类里面了。</p><h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><h2 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h2><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h2 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h2><h1 id="八、异常和代码质量测试，防止你被祭天"><a href="#八、异常和代码质量测试，防止你被祭天" class="headerlink" title="八、异常和代码质量测试，防止你被祭天"></a>八、异常和代码质量测试，防止你被祭天</h1><p>​在公开发行的游戏中，尤其是手游，当出现严重的bug时，人们往往要献祭程序员（当然是玩笑话），mc除外，那叫“特性”。为了防止你的游戏bug惹众怒，就需要对我们的代码进行质量测试。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h4><p>​异常是java特有的一种机制，异常，就是不正常的意思。而在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响。在程序中的意思就是：程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p><ul><li>异常指的并不是<strong>语法错误</strong>,语法错了,编译不通过,不会产生字节码文件,根本不能运行。</li><li>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。</li><li>Java为异常设计了一套<strong>异常处理机制</strong>，当程序运行过程中发生一些异常情况时，程序不会返回任何值，而是抛出封装了错误信息的异常对象。这样保证程序代码更加优雅，并提高程序的健壮性。 为什么要设计异常呢？首先，引入异常之后，我们就可以把错误的代码从正常代码中分离出来进行单独处理，这样使代码变得更加整洁；其次，当出现一些特殊情况时，我们还可以抛出一个检查异常，告知调用者让其处理。</li></ul><p>​如果还是听不懂的话。。。。。。</p><p>java自身的api，它并不是完美无缺的。比如文件类的io，找不到文件，它会不知所措。某个数除以零，java酱也会感到茫然。例如所持物品变成了负数，怪物技能没有cd、列表里的好友一夜消失之类的，我们应当也视作异常。</p><p>当程序出现异常时，最好有异常的处理办法，来避免损失</p><h4 id="模拟一个异常"><a href="#模拟一个异常" class="headerlink" title="模拟一个异常"></a>模拟一个异常</h4><p>就拿一除以零举例吧。</p><p>当</p><h2 id="更深入的debug"><a href="#更深入的debug" class="headerlink" title="更深入的debug"></a>更深入的debug</h2><h2 id="质量测试和Junit"><a href="#质量测试和Junit" class="headerlink" title="质量测试和Junit"></a>质量测试和Junit</h2><h1 id="九、嘿！哥们，留住你的存档！"><a href="#九、嘿！哥们，留住你的存档！" class="headerlink" title="九、嘿！哥们，留住你的存档！"></a>九、嘿！哥们，留住你的存档！</h1><p>在之前的游戏开发中，你们一定发现了一个问题。</p><p>“存不了档啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！”</p><p>这节课我们就来讲如何存档，看下面的存档方式这么多，但是本质上都是一样的，都是将数据用函数固化在计算机的ROM上，而这种存储，我们称为持久化存储。</p><p>到这里就是一个阶段性的飞跃，我们能将进度保存，就有了更多的可能性，视觉小说可以放更长的剧情，卷轴闯关游戏可以放更长的关卡，z</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h3 id="javaIO类"><a href="#javaIO类" class="headerlink" title="javaIO类"></a>javaIO类</h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><h1 id="十、实用类-二"><a href="#十、实用类-二" class="headerlink" title="十、实用类 二"></a>十、实用类 二</h1><h2 id="去找好用的类"><a href="#去找好用的类" class="headerlink" title="去找好用的类"></a>去找好用的类</h2><h2 id="C语言调用"><a href="#C语言调用" class="headerlink" title="C语言调用"></a>C语言调用</h2><h1 id="十、常用工具-二"><a href="#十、常用工具-二" class="headerlink" title="十、常用工具 二"></a>十、常用工具 二</h1><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="什么是构建工具"><a href="#什么是构建工具" class="headerlink" title="什么是构建工具"></a>什么是构建工具</h3><p>​我们要写一个Java程序，一般的步骤也就是编译，测试，打包。这个构建的过程，如果文件比较少，我们可以手动使用java, javac, jar命令去做这些事情。但当工程越来越大，文件越来越多，这个事情就不是那么地令人开心了。因为这些命令往往都是很机械的操作。但是我们可以把机械的东西交给机器去做。</p><p>​构建工具是一个把源<a href="https://so.csdn.net/so/search?q=%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90&spm=1001.2101.3001.7020">代码生成</a>可执行应用程序的过程自动化的程序（例如Android app生成apk）。构建包括编译、连接跟把代码打包成可用的或可执行的形式。</p><p>基本上构建的自动化是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常，像是：</p><ol><li>下载依赖</li><li>将源代码编译成二进制代码</li><li>打包生成的二进制代码</li><li>进行单元测试</li><li>部署到生产系统</li></ol><p>java早期的构建工具是ant，但是这工具有个毛病，那就是没办法管理依赖。我们一个工程，要使用很多第三方工具，不同的工具，不同的版本。每次打包都要自己手动去把正确的版本拷到lib下面去，不用说，这个工作既枯燥还特别容易出错。为了解决这个问题，maven闪亮登场。</p><p>maven最核心的改进就在于提出仓库这个概念。我可以把所有依赖的包，都放到仓库里去，在我的工程管理文件里，标明我需要什么什么包，什么什么版本。在构建的时候，maven就自动帮我把这些包打到我的包里来了。我们再也不用操心着自己去管理几十上百个jar文件了。</p><p>这了达到这个目标，maven提出，要给每个包都标上坐标，这样，便于在仓库里进行查找。所以，使用maven构建和发布的包都会按照这个约定定义自己的坐标。</p><h3 id="Maven和Gradle"><a href="#Maven和Gradle" class="headerlink" title="Maven和Gradle"></a>Maven和Gradle</h3><h1 id="十一、GUI-事情开始变得有趣了。。。"><a href="#十一、GUI-事情开始变得有趣了。。。" class="headerlink" title="十一、GUI?事情开始变得有趣了。。。"></a>十一、GUI?事情开始变得有趣了。。。</h1><h2 id="javaGUI现状"><a href="#javaGUI现状" class="headerlink" title="javaGUI现状"></a>javaGUI现状</h2><p>java最早的图形控件是awt，但是awt本身做的事情很少，只有简单的功能。如果想实现一些特殊的效果，就要有很多工作要做。</p><p>所以后来，sun公司发展出了swing，此时sun贯彻了一次编译，到处运行。但是，缺省界面丑，运行效率慢，Java在gui上落后了。</p><p>sun公司后来发现，swing也不行了，就在临死前搞出了javafx。直到如今，javafx也是java官方推荐的技术。</p><h2 id="简单了解和使用ATW和Swing"><a href="#简单了解和使用ATW和Swing" class="headerlink" title="简单了解和使用ATW和Swing"></a>简单了解和使用ATW和Swing</h2><h2 id="JavaFx"><a href="#JavaFx" class="headerlink" title="JavaFx"></a>JavaFx</h2><h2 id="游戏物理学和ai"><a href="#游戏物理学和ai" class="headerlink" title="游戏物理学和ai"></a>游戏物理学和ai</h2><h1 id="十二、网络，开启多人互坑"><a href="#十二、网络，开启多人互坑" class="headerlink" title="十二、网络，开启多人互坑"></a>十二、网络，开启多人互坑</h1><h2 id="网络常识"><a href="#网络常识" class="headerlink" title="网络常识"></a>网络常识</h2><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>网络有两种分层模型</p><p>OSI（七层因特网协议栈）：分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>因特网协议栈：物理层、数据链路层、网络层、传输层、应用层。</p><p>你会问：“为什么要分层呢？”</p><p>因为分层了之后网络的各个部分都能各司其职，互不打扰，出现问题时也方便寻找维护。</p><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来，游戏也不例外。</p><p>java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信可以直接使用这些类，而不用关心底层细节</p><h4 id="网络协议支持"><a href="#网络协议支持" class="headerlink" title="网络协议支持"></a>网络协议支持</h4><p>java.net 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>TCP</strong>：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP &#x2F; IP。</p></li><li><p><strong>UDP</strong>：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</p></li><li><h4 id="java-Socket"><a href="#java-Socket" class="headerlink" title="java Socket"></a>java Socket</h4><p>Sock译为套接字，是实现软件通信的重要手段，</p></li></ul><p>​套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p><p>​当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p><h2 id="服务器实现"><a href="#服务器实现" class="headerlink" title="服务器实现"></a>服务器实现</h2><p>先复制粘贴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 GreetingClient.java</span><br> <br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreetingClient</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span><br>   &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">serverName</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">try</span><br>      &#123;<br>         System.out.println(<span class="hljs-string">&quot;连接到主机：&quot;</span> + serverName + <span class="hljs-string">&quot; ，端口号：&quot;</span> + port);<br>         <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(serverName, port);<br>         System.out.println(<span class="hljs-string">&quot;远程主机地址：&quot;</span> + client.getRemoteSocketAddress());<br>         <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outToServer</span> <span class="hljs-operator">=</span> client.getOutputStream();<br>         <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(outToServer);<br> <br>         out.writeUTF(<span class="hljs-string">&quot;Hello from &quot;</span> + client.getLocalSocketAddress());<br>         <span class="hljs-type">InputStream</span> <span class="hljs-variable">inFromServer</span> <span class="hljs-operator">=</span> client.getInputStream();<br>         <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(inFromServer);<br>         System.out.println(<span class="hljs-string">&quot;服务器响应： &quot;</span> + in.readUTF());<br>         client.close();<br>      &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>      &#123;<br>         e.printStackTrace();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 GreetingServer.java</span><br> <br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreetingServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span><br>&#123;<br>   <span class="hljs-keyword">private</span> ServerSocket serverSocket;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">GreetingServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException<br>   &#123;<br>      serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>      serverSocket.setSoTimeout(<span class="hljs-number">10000</span>);<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>   &#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>      &#123;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待远程连接，端口号为：&quot;</span> + serverSocket.getLocalPort() + <span class="hljs-string">&quot;...&quot;</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;远程主机地址：&quot;</span> + server.getRemoteSocketAddress());<br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(server.getInputStream());<br>            System.out.println(in.readUTF());<br>            <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(server.getOutputStream());<br>            out.writeUTF(<span class="hljs-string">&quot;谢谢连接我：&quot;</span> + server.getLocalSocketAddress() + <span class="hljs-string">&quot;\nGoodbye!&quot;</span>);<br>            server.close();<br>         &#125;<span class="hljs-keyword">catch</span>(SocketTimeoutException s)<br>         &#123;<br>            System.out.println(<span class="hljs-string">&quot;Socket timed out!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>         &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span><br>   &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">try</span><br>      &#123;<br>         <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreetingServer</span>(port);<br>         t.run();<br>      &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>      &#123;<br>         e.printStackTrace();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十三、使游戏更快、更灵活、更稳定的方法"><a href="#十三、使游戏更快、更灵活、更稳定的方法" class="headerlink" title="十三、使游戏更快、更灵活、更稳定的方法"></a>十三、使游戏更快、更灵活、更稳定的方法</h1><h2 id="那么，是哪些方法？"><a href="#那么，是哪些方法？" class="headerlink" title="那么，是哪些方法？"></a>那么，是哪些方法？</h2><h2 id="多线程-告别祖传单核"><a href="#多线程-告别祖传单核" class="headerlink" title="多线程 告别祖传单核"></a>多线程 告别祖传单核</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>进程是执行程序的一次执行过程，是系统分配资源的单位</p><p>一个进程有多个线程，一个进程至少有一个线程。线程是独立的执行路径。</p><p>在程序运行时，即使没有自己创建线程。，后台也会有多个线程，如主线程、gc线程。</p><p>main（）被称为主线程，为程序的入口，用于执行整个程序。</p><p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统密切相关的，先后顺序是不能人为的干预的。</p><p>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。</p><p>线程会带来额外的开销，如cpu调度时间，并发控制开销</p><p>每个线程都在自己的工作内存交互，内存控制不当会造成数据不一致。</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>创建一个线程有三种方法</p><p>1、继承Thread类</p><p>2、实现Runnable接口</p><p>3、实现Callable接口（仅作了解）</p><h4 id="方法1-继承Thread类"><a href="#方法1-继承Thread类" class="headerlink" title="方法1 继承Thread类"></a>方法1 继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式1：继承Thread类，重写run方法()，调用Start开启线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//run方法，线程体</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看教程，焦头烂额&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建线程对象</span><br>        testThread1 testThread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">testThread1</span>();<br>        testThread1.start();<span class="hljs-comment">//开启多线程，执行线程里面的run()方法</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;我在写文档&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="方法2-实现Runnable接口"><a href="#方法2-实现Runnable接口" class="headerlink" title="方法2 实现Runnable接口"></a>方法2 实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法2：实现runnble接口，重写run方法，执行线程时需要丢入runnable接口的实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//run方法，线程体</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在看教程，焦头烂额&quot;</span>);<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建线程对象</span><br>        testThread2 testThread2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">testThread2</span>();<br>        <span class="hljs-comment">//创建线程对象，通过线程对象进行代理</span><br>        Thread t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testThread2);<br>        testThread2.run();<br><br>        <span class="hljs-comment">//new Thread(testThread2).start(); //另一种方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;我在写文档&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>继承runnable接口避免了java类单继承的缺点，方便一个对象被多个线程使用。</p><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>从一个例子开始，多个线程同时抢一个票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> gushanxc;<br><br><span class="hljs-comment">//问题：多个现场操作同一个资源，线程不安全了，数据紊乱</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ticketNums=<span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span> (ticketNums&lt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//模拟延时</span><br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了第&quot;</span>+ticketNums--+<span class="hljs-string">&quot;票&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testThread3 ticket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">testThread3</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket,<span class="hljs-string">&quot;晴晴&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket,<span class="hljs-string">&quot;孤山&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket,<span class="hljs-string">&quot;黄牛&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="案例：龟兔赛跑"><a href="#案例：龟兔赛跑" class="headerlink" title="案例：龟兔赛跑"></a>案例：龟兔赛跑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> gushanxc;<br><span class="hljs-comment">//模拟龟兔赛跑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Race</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String winner;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">//模拟兔子休息</span><br>            <span class="hljs-keyword">if</span> (Thread.currentThread().getName()==<span class="hljs-string">&quot;tu&quot;</span> &amp;&amp; i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> gameOver(i);<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;跑了&quot;</span>+i+<span class="hljs-string">&quot;步&quot;</span>);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否完成比赛</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">gameOver</span><span class="hljs-params">(<span class="hljs-type">int</span> steps)</span>&#123;<br>        <span class="hljs-comment">//判断是否有胜利者</span><br>        <span class="hljs-keyword">if</span> (winner!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (steps&gt;=<span class="hljs-number">100</span>)&#123;<br>            winner=Thread.currentThread().getName();<br>            System.out.println(<span class="hljs-string">&quot;winner is &quot;</span>+winner);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Race race=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Race</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(race,<span class="hljs-string">&quot;gui&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(race,<span class="hljs-string">&quot;tu&quot;</span>).start();<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h3><h4 id="lamda"><a href="#lamda" class="headerlink" title="lamda"></a>lamda</h4><p>Lambda表达式的作用是避免匿名内部类定义太多，让代码看起来更简洁。属于函数式编程。</p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>任何接口，如果只包含一个抽象方法，那么就是一个函数式接口。</p><p>对于函数式借口，可以通过Lamda表达式来创建该接口的对象。</p><h3 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h3><h4 id="线程5大状态"><a href="#线程5大状态" class="headerlink" title="线程5大状态"></a>线程5大状态</h4><p>创建、就绪、运行、阻塞、死亡</p><h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><p>一般不使用jdk的stop方法，而是线程正常停止或用标志位停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> gushanxc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testThread5</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span><span class="hljs-literal">true</span>; <span class="hljs-comment">//标识符</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (flag)&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程运行中&quot;</span>+(i++));<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testThread5 t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">testThread5</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main&quot;</span>+i);<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">900</span>)&#123;<br>                t.stop();<br>                System.out.println(<span class="hljs-string">&quot;线程该停止了&quot;</span>);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag=<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p>sleep(time) 让线程阻塞一段时间，单位是毫秒。</p><p>sleep有异常InterruptedException;</p><p>sleep时间达到后线程进入就绪状态</p><p>sleep可以模拟网络延时、倒计时等。</p><p>每一个对象都有一个锁，sleep不会释放锁。</p><p><strong>倒计时案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> gushanxc;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testThread6_1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Date</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis());<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               Thread.sleep(<span class="hljs-number">1000</span>);<br>               System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:MM:ss&quot;</span>).format(startTime));<br>               startTime=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis());<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testThread6_1 ticket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">testThread6_1</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><p>礼让线程，是让当前执行的现场暂停，但不堵塞</p><p>将线程从运行状态转为就绪状态</p><p>让cpu重新调度，礼让不一定成功</p><h4 id="线程监测"><a href="#线程监测" class="headerlink" title="线程监测"></a>线程监测</h4><p>一个已经死亡的现场不能再执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> gushanxc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testThread9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;/////&quot;</span>);<br>            &#125;<br>        &#125;);<br>        Thread.<span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> thread.getState();<br>        System.out.println(state);<br><br>        thread.start();<br>        state = thread.getState();<br>        System.out.println(state);<br><br>        <span class="hljs-comment">//只要线程不终止</span><br>        <span class="hljs-keyword">while</span> (state !=Thread.State.TERMINATED)&#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            state = thread.getState();<span class="hljs-comment">//更新线程状态</span><br>            System.out.println(state);<br>        &#125;<br>        state = thread.getState();<br>        System.out.println(state);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度按照优先级用数字表示，范围从1~10.</p><p>现场调度优先级越大，就越有可能获得资源</p><p>用以下方法改变或获取优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">getPriority();<br>setPriority(<span class="hljs-type">int</span> xxx);<br></code></pre></td></tr></table></figure><p>优先级的设定最好在start()调度前。</p><p>优先级低的反而先运行被称为性能倒置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> gushanxc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">textThread10</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Mythread2 mythread2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Mythread2</span>();<br>        Thread thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mythread2);<br>        Thread thread2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mythread2);<br>        Thread thread3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mythread2);<br>        Thread thread4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mythread2);<br>        Thread thread5=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mythread2);<br>        Thread thread6=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mythread2);<br><br>        thread2.setPriority(<span class="hljs-number">1</span>);<br><br>        thread1.start();<br>        thread2.start();<br><br>        thread4.setPriority(Thread.MAX_PRIORITY);<br>        thread4.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mythread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>线程分为用户线程和守护线程</p><p>虚拟机必须保证用户线程执行完毕</p><p>虚拟机不用等待守护线程执行完毕</p><p>守护现场举例：后台记录日志、内存健康、垃圾回收等待</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>处理多线程访问一个对象，并且一些一些现场还要修改这个对象，这时候就需要现场同步，线程同步是一种等待极致，多个需要同时访问同一对象的现场要进入这个对象的等待池形成队列，等待前面线程使用完毕再使用。</p><p>线程同步的形成条件：队列+锁</p><p>为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排他锁，独占资源，其他对象必须等待，使用后释放锁即可，存在以下问题：</p><p>一个线程持有锁会导致其他需要此锁的线程挂起；</p><p>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>如果一个优先级高的线程等待一个优先级低的线程释放，会引起性能倒置，引起性能问题</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解概念"><a href="#注解概念" class="headerlink" title="注解概念"></a>注解概念</h3><p>注解，也叫Annotation，是从jdk5.0开始引入的新技术。</p><ul><li><p>Annotation的作用</p><p>不是程序本身，但是可以对程序做出解释</p><p>可以被其他程序读取</p></li><li><p>Annotation的格式</p><p>注解是以“@注释名”在代码中存在的，还可以添加一些参数值（例@SuppressWarnings(value&#x3D;null)）</p></li><li><p>Annotation在哪里使用</p><p>可以附加在package、class、method、field等上面，相当于添加了额外的辅助信息，可以通过反射机制来实现对这些元数据的访问。</p></li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&#123;<br>    <span class="hljs-comment">//@Override代表重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>@Override：表示一个方法打算重写超类中的另一个方法声明</p><p>@Deprecated：可修辞方法、属性、类，表示不建议使用这样的元素，因为很不稳定或有更好的选择。</p><p>@SuppressWarnings：镇压警告，用来抑制编译错误时的警告，至少要有一个参数。</p><p>​例如：@SuppressWarnings(“all”)、@SuppressWarnings(“unchecked”)</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解的作用是负责解释其他注解，java定义了4个标准的meta-annotation类型，被用来提供对其他annotation类型做说明。</p><p>@Target：用来描述注解的使用范围</p><p>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。</p><p>@Document：说明该注解将被包含在javadoc中</p><p>@Inherited：说明子类可以继承父类中的该注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注解可以用在哪些地方</span><br><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="hljs-comment">//注解在什么地方有效</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">//是否将注解生成在JavaDoc中</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-comment">//子类可以继承父类的注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>在使用@interface自定义注解时，自动继承了java.lang.annotatior.Annotation</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>​反射被java视为动态语言的关键，反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作类的内部信息。</p><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><p>动态语言在运行时可以改变其结构，新的函数、对象甚至代码都可以被引进，例如：PHP、C#、Js、PHP、Python</p><p>静态语言在运行时结构不可变，比如java、C、C++</p><p>java可以通过反射机制获得类似动态语言的特性</p><h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>反射是java被视为动态语言的关键，反射机制允许对象执行期间借助Reflection apl取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure><p>反射可以动态实现创建对象和编译，有很大灵活性，但是对性能有影响</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h1 id="十四、java游戏框架使用"><a href="#十四、java游戏框架使用" class="headerlink" title="十四、java游戏框架使用"></a>十四、java游戏框架使用</h1><h2 id="关于框架"><a href="#关于框架" class="headerlink" title="关于框架"></a>关于框架</h2><p>到这里大家是不是感觉做游戏很麻烦呢？只是制作一个角色行走的动画就要半天。</p><p>不用担心，java经过这么长的发展时间，早就有第三方的游戏框架了，有Java Fxgl、libGDX、lgame、java monkey engine等，可以使我们的游戏开发变得很容易。</p><p>首先介绍Flgx</p><h2 id="Flgx"><a href="#Flgx" class="headerlink" title="Flgx"></a>Flgx</h2><p>FXGL 是一个基于JavaFX 游戏开发的框架，这也是之前讲javafx的原因，这个框架有两个版本，其中基于JDK1.8的版本已经不再维护，目前最新的是基于JDK11的版本，也就是Openjfx的版本。</p><p>你可能会问，有这么好的框架，为什么不早告诉我们？</p><p>因为想要用编程的任何框架，你都要有前置的基础，如果没学多少东西，就直接上手框架，你会一脸懵逼，最后芝麻西瓜都丢了，从此放弃。</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h2 id="lgame"><a href="#lgame" class="headerlink" title="lgame"></a>lgame</h2><h2 id="在java之外的引擎"><a href="#在java之外的引擎" class="headerlink" title="在java之外的引擎"></a>在java之外的引擎</h2><h3 id="unity"><a href="#unity" class="headerlink" title="unity"></a>unity</h3><h3 id="ue4"><a href="#ue4" class="headerlink" title="ue4"></a>ue4</h3><h3 id="RpgMarker"><a href="#RpgMarker" class="headerlink" title="RpgMarker"></a>RpgMarker</h3><h3 id="Ren’py"><a href="#Ren’py" class="headerlink" title="Ren’py"></a>Ren’py</h3><h3 id="泛html"><a href="#泛html" class="headerlink" title="泛html"></a>泛html</h3><p>​由于java在图形界面的领域的失败，越来越多的公司将自己的界面搬到浏览器上，也就是所谓的html和css。java做后端更合适，貌似已经成为大家的共识。</p><p>​我做这个教程，也算是逆流而行，其实到下一章，会变得很硬核，对于学java的目的是要就业的人来说，其实在这里就可以停下来，或者跳到十四章学完后离开。</p><p>​如果你是出于兴趣来的，就可以往下走，不过游戏业界的主流还不是java，可要想好。</p><h1 id="十五、java与底层图形音频api"><a href="#十五、java与底层图形音频api" class="headerlink" title="十五、java与底层图形音频api"></a>十五、java与底层图形音频api</h1><h1 id="十六、java与前端的联动，网页游戏"><a href="#十六、java与前端的联动，网页游戏" class="headerlink" title="十六、java与前端的联动，网页游戏"></a>十六、java与前端的联动，网页游戏</h1><h1 id="十七、游戏实战1：视觉小说"><a href="#十七、游戏实战1：视觉小说" class="headerlink" title="十七、游戏实战1：视觉小说"></a>十七、游戏实战1：视觉小说</h1><h2 id="1、游戏策划和实现分析"><a href="#1、游戏策划和实现分析" class="headerlink" title="1、游戏策划和实现分析"></a>1、游戏策划和实现分析</h2><h2 id="2、GUI实现"><a href="#2、GUI实现" class="headerlink" title="2、GUI实现"></a>2、GUI实现</h2><h2 id="3、数据读取实现"><a href="#3、数据读取实现" class="headerlink" title="3、数据读取实现"></a>3、数据读取实现</h2><h2 id="4、存档实现"><a href="#4、存档实现" class="headerlink" title="4、存档实现"></a>4、存档实现</h2><h1 id="番外篇、Minecraft模组开发"><a href="#番外篇、Minecraft模组开发" class="headerlink" title="番外篇、Minecraft模组开发"></a>番外篇、Minecraft模组开发</h1><h2 id="关于这个章节"><a href="#关于这个章节" class="headerlink" title="关于这个章节"></a>关于这个章节</h2><p>​Minecraft，中文译名是“我的世界”，世界上最流行的游戏之一，前面第零章也说过，我是因为喜欢这个游戏想要做模组而去学习java的，现在，我想弥补当时的遗憾，再战模组开发，然后写出来实现过程在此给大家分享。</p><p>​本章是选修章节，喜欢Minecraft并且也想开发自己的模组的朋友可以学习。</p><h2 id="Minecraft模组的分类"><a href="#Minecraft模组的分类" class="headerlink" title="Minecraft模组的分类"></a>Minecraft模组的分类</h2><p>目前pc java端的模组有两大阵营（加载器），分别是forge和frbaic。</p><p>​forge是老大哥，很早就有了，在1.2.5那个版本开始出现，那时还要靠麻烦的文件覆盖。1.6.2终于可以把文件放在mods文件夹来加载了。之后的1.7.10是模组大繁荣的版本，下一个模组繁荣版本是1.12.2。</p><p>​因为1.13海洋更新版本改动太大了。所以forge没有更新这个版本。所以这里出现了一个新加载器：Rift，但是只持续了一个版本。之后开发者也去了frbaic那边。</p><p>​frbaic是1.14及之后新兴的的模组加载器，Fabric轻量、提前支持高版本的minecraft、不会像Forge那样出现各种各样的问题。但是forge作为老大哥，早就已经脱离了API的范畴，在原版的基础上分离出了event系统，另外附加了capabilities，发包等系统，开发方便。各有好处吧。</p><p>​本章将会用Minecraft 1.18.2版本下的Fabric开发，带你走过MC mod制作的各个环节。</p><h2 id="Fabric环境的安装"><a href="#Fabric环境的安装" class="headerlink" title="Fabric环境的安装"></a>Fabric环境的安装</h2><h2 id="第一个物品"><a href="#第一个物品" class="headerlink" title="第一个物品"></a>第一个物品</h2><h1 id="十八、游戏实战2：坦克大战"><a href="#十八、游戏实战2：坦克大战" class="headerlink" title="十八、游戏实战2：坦克大战"></a>十八、游戏实战2：坦克大战</h1><h2 id="1、游戏策划和实现分析-1"><a href="#1、游戏策划和实现分析-1" class="headerlink" title="1、游戏策划和实现分析"></a>1、游戏策划和实现分析</h2><h2 id="方法1：传统gui"><a href="#方法1：传统gui" class="headerlink" title="方法1：传统gui"></a>方法1：传统gui</h2><h3 id="2、贴图提取和GUI实现"><a href="#2、贴图提取和GUI实现" class="headerlink" title="2、贴图提取和GUI实现"></a>2、贴图提取和GUI实现</h3><h3 id="3、数据读取实现-1"><a href="#3、数据读取实现-1" class="headerlink" title="3、数据读取实现"></a>3、数据读取实现</h3><h2 id="方法2：Flgl引擎"><a href="#方法2：Flgl引擎" class="headerlink" title="方法2：Flgl引擎"></a>方法2：Flgl引擎</h2><h1 id="十九、游戏实战3：植物大战僵尸"><a href="#十九、游戏实战3：植物大战僵尸" class="headerlink" title="十九、游戏实战3：植物大战僵尸"></a>十九、游戏实战3：植物大战僵尸</h1><h2 id="1、游戏策划和实现分析-2"><a href="#1、游戏策划和实现分析-2" class="headerlink" title="1、游戏策划和实现分析"></a>1、游戏策划和实现分析</h2><h2 id="2、贴图制作和GUI实现"><a href="#2、贴图制作和GUI实现" class="headerlink" title="2、贴图制作和GUI实现"></a>2、贴图制作和GUI实现</h2><h1 id="二十、山寨版Minecraft"><a href="#二十、山寨版Minecraft" class="headerlink" title="二十、山寨版Minecraft"></a>二十、山寨版Minecraft</h1><h2 id="1、对原版mc实现的分析"><a href="#1、对原版mc实现的分析" class="headerlink" title="1、对原版mc实现的分析"></a>1、对原版mc实现的分析</h2><h1 id="二十一、游戏实战4：简单fps游戏实现"><a href="#二十一、游戏实战4：简单fps游戏实现" class="headerlink" title="二十一、游戏实战4：简单fps游戏实现"></a>二十一、游戏实战4：简单fps游戏实现</h1><h1 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h1><h2 id="引擎、语言、轮子"><a href="#引擎、语言、轮子" class="headerlink" title="引擎、语言、轮子"></a>引擎、语言、轮子</h2><h2 id="如果你想进入ACG行业"><a href="#如果你想进入ACG行业" class="headerlink" title="如果你想进入ACG行业"></a>如果你想进入ACG行业</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java“基础“，从“你好世界”到简单游戏&quot;&gt;&lt;a href=&quot;#java“基础“，从“你好世界”到简单游戏&quot; class=&quot;headerlink&quot; title=&quot;java“基础“，从“你好世界”到简单游戏&quot;&gt;&lt;/a&gt;java“基础“，从“你好世界”到简单游戏&lt;/</summary>
      
    
    
    
    <category term="-游戏开发-" scheme="https://gushan233.xyz/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="-java-, -游戏开发-" scheme="https://gushan233.xyz/tags/java-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
